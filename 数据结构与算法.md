# 数据结构与算法

### 时间复杂度

#### 比较：O**(1)<O(log n)<O(n)<O(n*log n)<O(n^2)**<O(n^3)<O(2^n)<O(n!)<O(n^n)

#### masert公式(估计时间复杂度): T(n)=a*T(n/b)+O(n^c) 相同子问题规模才能适用(递归)

#### 空间复杂度：递归的空间复杂度是递归树的深度

### 位运算：|：或 &：与  ^：异或  ~ ：取反  

### 逻辑运算：|| && 两边不会都要执行

### 异或运算：无进位相加

#### 1.交换 a=a^b b=a^b a=a^b

#### 2.get_max值 

```
//1.交换
int arr[105];
//i j一定不能相等
void swap(int i,int j) {
	arr[i] = arr[i] ^ arr[j];
	arr[j] = arr[i] ^ arr[j];
	arr[i] = arr[i] ^ arr[j];
}
signed main() {
	int a = 999;
	int b = -3455;
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	cout << a <<" "<< b << '\n';
	arr[1] = 1345;
	arr[4] = -345;
	swap(1, 4);
	cout << arr[1] << " " << arr[4] << '\n';
	return 0;
}

//2.get_max
//保证n为0或1
//0变成1 1变成0
int flip(int n) {
	return n ^ 1;
}
//非负返回1 负数返回0
int sign(int n) {
	return (flip(n >> 31)&1);
}
//存在溢出
int get_max1(int a,int b) {
	int c = a - b;
	//c非负 returnA---->1
	//c非负 returnB---->0
	//c负数 returnA---->0
	//c负数 returnB---->1
	int returnA = sign(c);
	int returnB = flip(returnA);
	return a * returnA + b * returnB;
}
//改进版
int get_max2(int a,int b) {
	//c可能溢出
	int c = a - b;
	//a b,c 符号
	int sa = sign(a);
	int sb = sign(b);
	int sc = sign(c);
	//判断a b符号是否一样 是diffab为0 sameab为1 否diffab为1 sameab为0
	int diffab = sa ^ sb;
	int sameab = flip(diffab);
	int returnA = diffab * sa + sameab * sc;
	int returnB = flip(returnA);
	return a * returnA + b * returnB;
}
signed main() {
	int a, b;
	cin >> a >> b;
	cout << get_max1(a,b) << '\n';
	cout << get_max2(a,b) << '\n';
	return 0;
}

//3.get_missnumber
int missingNumber(std::vector<int>& nums) {
    int eorAll = 0, eorHas = 0;
    for (int i = 0; i < nums.size(); i++) {
        eorAll ^= i;
        eorHas ^= nums[i];
    }
    eorAll ^= nums.size();
    return eorAll ^ eorHas;
}
signed main() {
    std::vector<int> nums = { 0, 1, 3 }; // 示例输入数组
    int missing = missingNumber(nums);
    std::cout << "Missing number: " << missing << std::endl;
    return 0;
}

//4.数组中1种数出现了奇数次，其他的数都出现了偶数次
// 返回出现了奇数次的数
int singleNumber(std::vector<int>& nums) {
    int eor = 0;
    for (int num : nums) {
        eor ^= num;
    }
    return eor;
}
signed main() {
    std::vector<int> nums = { 2, 2, 1 }; // 示例输入数组
    int single = singleNumber(nums);
    std::cout << "Single number: " << single << std::endl;
    return 0;
}

//数组中有2种数出现了奇数次，其他的数都出现了偶数次
//返回这2种出现了奇数次的数
std::vector<int> singleNumber(std::vector<int>& nums) {
    int eor1 = 0;
    for (int num : nums) {
        eor1 ^= num;
        //eor1=a^b
    }
    // Brian Kernighan算法
	// 提取出二进制里最右侧的1
    int rightOne = eor1 & (-eor1);
    int eor2 = 0;
    for (int num : nums) {
        if ((num & rightOne) == 0) {
            eor2 ^= num;
        }
    }
    return { eor2, eor1 ^ eor2 };
}
signed main() {
    std::vector<int> nums = { 2, 4, 3, 6, 3, 2, 5, 5 }; // 示例输入数组
    std::vector<int> singles = singleNumber(nums);
    std::cout << "Single numbers: " << singles[0] << " and " << singles[1] << std::endl;
    return 0;
}

//数组中只有1种数出现次数少于m次，其他数都出现了m次
//返回出现次数小于m次的那种数
int find(const vector<int>& arr, int m) {
    vector<int> cnts(32, 0);
    for (int num : arr) {
        for (int i = 0; i < 32; i++) {
            cnts[i] += (num >> i) & 1;
        }
    }
    int ans = 0;
    for (int i = 0; i < 32; i++) {
        if (cnts[i] % m != 0) {
            ans |= 1 << i;
        }
    }
    return ans;
}
int singleNumber(const vector<int>& nums) {
    return find(nums, 3);
}
signed main() {
    vector<int> nums = { 1, 2, 2, 1, 3, 1, 2 };
    cout << "Single number with less than 3 occurrences: " << singleNumber(nums) << endl;
    return 0;
}

// 判断一个整数是不是2的幂
int solve() {
	int n;
	cin >> n;
	return n > 0 && n == (n & -n);
}
signed main() {
	cout << solve() << '\n';
}

// 判断一个整数是不是3的幂
int solve() {
	int n;
	cin >> n;
// 如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子
// 1162261467是int型范围内，最大的3的幂，它是3的19次方
// 这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么
// 1162261467 % n == 0
// 反之如果1162261467 % n != 0 说明n一定含有其他因子
	return n > 0 && 1162261467 % n == 0;
}
signed main() {
	cout << solve() << '\n';
}

// 已知n是非负数
// 返回大于等于n的最小的2某次方
// 如果int范围内不存在这样的数，返回整数最小值
int near2power(int n) {
	if (n <= 0)
		return 1;
	n--;
	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;
	return n + 1;
}
void solve() {
	int n;
	cin >> n;
	cout << near2power(n) << '\n';
}
signed main() {
	solve();
	return 0;
}

//给你两个整数 left 和 right ，表示区间 [left, right]
//返回此区间内所有数字 & 的结果
//包含 left 、right 端点
int rangeBitwiseAnd(int left, int right) {
	while (left < right) {
		right -= right & -right;
	}
	return right;
}
void solve() {
	int left, right;
	cin >> left >> right;
	cout << rangeBitwiseAnd(left,right)<< '\n';
}
signed main() {
	solve();
	return 0;
}

//逆序二进制的状态-----分治
int reverseBits(int n) {
	n = ((n & 0xaaaaaaaa) >>  1) | ((n & 0x55555555) << 1);
	n = ((n & 0xcccccccc) >>  2) | ((n & 0x33333333) << 2);
	n = ((n & 0xf0f0f0f0) >>  4) | ((n & 0x0f0f0f0f) << 4);
	n = ((n & 0xff00ff00) >>  8) | ((n & 0x00ff00ff) << 8);
	n = (n >> 16) | (n << 16);
	return n;
}
void solve() {
	int n;
	cin >> n;
	cout << reverseBits(n) << '\n';
}
signed main() {
	solve();
	return 0;
}

//返回n的二进制中有几个1
//两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
//给你两个整数 x 和 y，计算并返回它们之间的汉明距离
//位运算
int cntOnes(int n) {
	n = (n & 0x55555555) + ((n >>  1) & 0x55555555);
	n = (n & 0x33333333) + ((n >>  2) & 0x33333333);
	n = (n & 0x0f0f0f0f) + ((n >>  4) & 0x0f0f0f0f);
	n = (n & 0x00ff00ff) + ((n >>  8) & 0x00ff00ff);
	n = (n & 0x0000ffff) + ((n >>  16) & 0x0000ffff);
	return n;
}
//c++函数__builtin_popcount 只能int,long ,long long 
int cntOnes(int n){
	return __builtin_popcount(n);
}
int hammingDistance(int x, int y) {
	return cntOnes(x ^ y);
}
void solve(){
	int a, b;
	cin >> a >> b;
	hammingDistance(a, b);
}
signed main(){
    solve();
    return 0;
}
```

### 位图(连续集合且范围不大)：用bit组成的数组存值，0/1代表存在/不存在，取值和存值都用位运算

#### 移动：

##### (非负)  左移 <<      右移>>   用0补

##### (对非负) <<i 即乘以2的i次方  >>i 即除以2的i次方

##### (负)  左移 <<      右移>>  用符号位补 

##### 左移 <<<    右移>>>  用0补

```
// 位图的实现
class Bitset {
public:
    std::vector<int> set;
    Bitset(int n) {
        set.resize((n + 31) / 32, 0);
    }
    void add(int num) {
        set[num / 32] |= 1 << (num % 32);
    }
    void remove(int num) {
        set[num / 32] &= ~(1 << (num % 32));
    }
    void reverse(int num) {
        set[num / 32] ^= 1 << (num % 32);
    }
    bool contains(int num) const {
        return (set[num / 32] & (1 << (num % 32))) != 0;
    }
};
signed main() {
    int n = 1000; // 位图大小
    int testTimes = 10000; // 测试次数
    std::cout << "测试开始" << std::endl;
    Bitset bitSet(n); // 初始化位图
    std::unordered_set<int> hashSet; // 对应HashSet
    std::srand(std::time(0)); // 初始化随机数生成器
    std::cout << "调用阶段开始" << std::endl;
    for (int i = 0; i < testTimes; i++) {
        double decide = (double) std::rand() / RAND_MAX; // 随机决定操作类型
        int number = std::rand() % n; // 随机选择数字
        if (decide < 0.333) {
            bitSet.add(number);
            hashSet.insert(number);
        } else if (decide < 0.666) {
            bitSet.remove(number);
            hashSet.erase(number);
        } else {
            bitSet.reverse(number);
            if (hashSet.find(number) != hashSet.end()) {
                hashSet.erase(number);
            } else {
                hashSet.insert(number);
            }
        }
    }
    std::cout << "调用阶段结束" << std::endl;
    std::cout << "验证阶段开始" << std::endl;
    bool error = false;
    for (int i = 0; i < n; i++) {
        if (bitSet.contains(i) != (hashSet.find(i) != hashSet.end())) {
            std::cout << "出错了!" << std::endl;
            error = true;
            break;
        }
    }
    if (!error) {
        std::cout << "所有测试通过!" << std::endl;
    }
    std::cout << "验证阶段结束" << std::endl;
    std::cout << "测试结束" << std::endl;
    return 0;
}

//加减乘除
// 常量，表示最小整数
const int MIN = INT_MIN;
// 加法函数，使用位运算
int add(int a, int b) {
    while (b != 0) {
        int carry = (a & b) << 1; // 进位
        a = a ^ b; // 无进位加法
        b = carry; // 更新b为进位
    }
    return a;
}
// 取反函数，返回相反数
int neg(int n) {
    return add(~n, 1); // 按位取反加1
}
// 减法函数，使用加法和取反
int minus(int a, int b) {
    return add(a, neg(b));
}
// 乘法函数，基于位运算
int multiply(int a, int b) {
    int result = 0;
    while (b != 0) {
        if (b & 1) { // 如果b的当前位是1
            result = add(result, a); // 将a加到结果
        }
        a <<= 1; // a左移一位
        b >>= 1; // b右移一位
    }
    return result;
}
// 除法函数，考虑特殊情况
int Div(int a, int b) {
    int x = (a < 0) ? neg(a) : a; // 取绝对值
    int y = (b < 0) ? neg(b) : b; // 取绝对值
    int result = 0;
    for (int i = 30; i >= 0; i--) {
        if ((x >> i) >= y) {
            result |= (1 << i);
            x -= (y << i);
        }
    }
    return ((a < 0) ^ (b < 0)) ? neg(result) : result; // 符号处理
}
// 除法函数，处理特殊情况
int divide(int a, int b) {
    if (a == MIN && b == MIN) {
        return 1; // -2^31 / -2^31
    }
    if (b == MIN) {
        return 0; // 除数为MIN
    }
     //题目要求
    if (a == MIN && b == -1) {
        return INT_MAX; // 溢出情况，返回整数最大
    }

    if (a != MIN && b != MIN) {
        return Div(a, b); // 普通除法
    }
    // 处理MIN和其他数的除法
    a = add(a, b > 0 ? b : neg(b));
    int result = Div(a, b);
    return add(result, b > 0 ? -1 : 1); // 调整结果
}
signed main(){
    int a=3,b=2;
    cout<<add(a,b)<<'\n';
    cout<<divide(a,b)<<'\n';
    return 0;
}
```

### 输入和输出

#### 比赛：加速 数组尽量使用静态数组

##### 1.    ios::sync_with_stdio(false); //    让std :: cin和std :: cout不再经过缓冲区

##### 2.    ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);

##### // 通过tie(nullptr)来解除std :: cin和std :: cout之间的绑定，进一步加快执行效率。

##### 3.快读快写

```
inline int read(){
	int x=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0',ch=getchar();
		return x*f;
	}
}
```



## 线性表

### 顺序表(数组) 增删改查    O(n)

### 树状数组(维护可差分信息---累加和、累 乘积)：单次调用O(log n) 下标默认以1开始

#### 一维数组：单点增加，范围查询

```
//一维数组：单点增加 范围查询
const int MAXN = 500001;
//数组从下标1开始
vector<int> tree(MAXN);
int n, m;
//得到最右侧的1状态
//其他位置均为0
int lowbit(int i) {
    return i & -i;
}
void add(int i, int v) {
    while (i <= n) {
        tree[i] += v;
        i += lowbit(i);
    }
}
//返回1--i的累加和
int sum(int i) {
    int ans = 0;
    while (i > 0) {
        ans += tree[i];
        i -= lowbit(i);
    }
    return ans;
}
//返回l--r的累加和
int range(int l, int r) {
    return sum(r) - sum(l - 1);
}
signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1, v; i <= n; i++) {
        cin >> v;
        add(i, v);
    }
    for (int i = 1, op, b, c; i <= m; i++) {
        cin >> op >> b >> c;
        if (op == 1) {
            add(b, c);
        }
        else {
            cout << range(b, c) << '\n';
        }
    }
    return 0;
}
```

#### 一维数组：范围增加，单点查询

```
//范围增加 单点查询
const int MAXN = 500002;
vector<int> tree(MAXN);
int n, m;
int lowbit(int i) {
    return i & -i;
}
void add(int i, int v) {
    while (i <= n) {
        tree[i] += v;
        i += lowbit(i);
    }
}
//返回1--i的累加和
int sum(int i) {
    int ans = 0;
    while (i > 0) {
        ans += tree[i];
        i -= lowbit(i);
    }
    return ans;
}
//返回l--r的累加和
int range(int l, int r) {
    return sum(r) - sum(l - 1);
}
signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1, v; i <= n; i++) {
        cin >> v;
        add(i, v);
        add(i + 1, -v);
    }
    for (int i = 1; i <= m; i++) {
        int op;
        cin >> op;
        if (op == 1) {
            int l, r, v;
            cin >> l >> r >> v;
            add(l, v);
            add(r + 1, -v);
        }
        else {
            int index;
            cin >> index;
            cout << sum(index) << '\n';
        }
    }
    return 0;
}
```

#### 一维数组：范围增加，范围查询

```
//一维数组：范围增加 范围查询
const int MAXN = 100001;
long long info1[MAXN];  // 差分信息 Di
long long info2[MAXN];  // 差分加工信息 (i-1) * Di
int n, m;
int lowbit(int i) {
    return i & -i;
}
void add(long long* tree, int i, long long v) {
    while (i <= n) {
        tree[i] += v;
        i += lowbit(i);
    }
}
long long sum(long long* tree, int i) {
    long long ans = 0;
    while (i > 0) {
        ans += tree[i];
        i -= lowbit(i);
    }
    return ans;
}
// 原始数组中[l..r]每个数值+v
void addRange(int l, int r, long long v) {
    add(info1, l, v);
    add(info1, r + 1, -v);
    add(info2, l, (l - 1) * v);
    add(info2, r + 1, -r * v);
}
// 原始数组中[l..r]范围上的累加和
long long rangeSum(int l, int r) {
    return sum(info1, r) * r - sum(info2, r) - sum(info1, l - 1) * (l - 1) + sum(info2, l - 1);
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    long long cur;
    // 初始化数组
    for (int i = 1; i <= n; i++) {
        cin >> cur;
        addRange(i, i, cur);
    }
    int op, l, r;
    long long v;
    for (int i = 1; i <= m; i++) {
        cin >> op;
        if (op == 1) {  // 区间加法操作
            cin >> l >> r >> v;
            addRange(l, r, v);
        }
        else {  // 区间求和操作
            cin >> l >> r;
            cout << rangeSum(l, r) << '\n';
        }
    }
    return 0;
}
```

#### 二维数组：单点增加，范围查询

```
//二维数组：单点增加 范围查询
const int MAXN = 1010;  // 假设矩阵的最大尺寸为1000x1000，可以根据需要调整
int tree[MAXN][MAXN];
int nums[MAXN][MAXN];
int n, m, q;
int lowbit(int i) {
    return i & -i;
}
void add(int x, int y, int v) {
    for (int i = x; i <= n; i += lowbit(i)) {
        for (int j = y; j <= m; j += lowbit(j)) {
            tree[i][j] += v;
        }
    }
}
int sum(int x, int y) {
    int ans = 0;
    for (int i = x; i > 0; i -= lowbit(i)) {
        for (int j = y; j > 0; j -= lowbit(j)) {
            ans += tree[i][j];
        }
    }
    return ans;
}
void update(int x, int y, int v) {
    add(x, y, v - nums[x][y]);
    nums[x][y] = v;
}
int sumRegion(int a, int b, int c, int d) {
    return sum(c, d) - sum(a - 1, d) - sum(c, b - 1) + sum(a - 1, b - 1);
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            int val;
            cin >> val;
            update(i, j, val);
        }
    }
    cin >> q;
    while (q--) {
        int type, x1, y1, x2, y2;
        cin >> type >> x1 >> y1 >> x2;
        if (type == 1) {
            update(x1, y1, x2);
        }
        else if (type == 2) {
            cin >> y2;
            cout << sumRegion(x1, y1, x2, y2) << "\n";
        }
    }
    return 0;
}
```

#### 二维数组：范围增加，范围查询

```
//二维数组：范围增加 范围查询
const int MAXN = 2050;
const int MAXM = 2050;
int info1[MAXN][MAXM], info2[MAXN][MAXM], info3[MAXN][MAXM], info4[MAXN][MAXM];
int n, m;
int lowbit(int i) {
    return i & -i;
}
void add(int x, int y, int v) {
    int v1 = v;
    int v2 = x * v;
    int v3 = y * v;
    int v4 = x * y * v;
    for (int i = x; i <= n; i += lowbit(i)) {
        for (int j = y; j <= m; j += lowbit(j)) {
            info1[i][j] += v1;
            info2[i][j] += v2;
            info3[i][j] += v3;
            info4[i][j] += v4;
        }
    }
}
int sum(int x, int y) {
    int ans = 0;
    for (int i = x; i > 0; i -= lowbit(i)) {
        for (int j = y; j > 0; j -= lowbit(j)) {
            ans += (x + 1) * (y + 1) * info1[i][j] - (y + 1) * info2[i][j] - (x + 1) * info3[i][j] + info4[i][j];
        }
    }
    return ans;
}
void add(int a, int b, int c, int d, int v) {
    add(a, b, v);
    add(c + 1, d + 1, v);
    add(a, d + 1, -v);
    add(c + 1, b, -v);
}
int range(int a, int b, int c, int d) {
    return sum(c, d) - sum(a - 1, d) - sum(c, b - 1) + sum(a - 1, b - 1);
}
signed main() {
    char op;
    int a, b, c, d, v;
    scanf("%s", &op);
    scanf("%d%d", &n, &m);
    while (scanf("%s", &op) != EOF) {
        if (op == 'X') {
            scanf("%d%d", &n, &m);
        } else if (op == 'L') {
            scanf("%d%d%d%d%d", &a, &b, &c, &d, &v);
            add(a, b, c, d, v);
        } else {
            scanf("%d%d%d%d", &a, &b, &c, &d);
            printf("%d\n", range(a, b, c, d));
        }
    }
    return 0;
}
```

### RMQ区间最小值

```
void rmq_init(){
    for(int i=1;i<=N;i++)
        dp[i][0]=arr[i];//初始化
    for(int j=1;(1<<j)<=N;j++)
        for(int i=1;i+(1<<j)-1<=N;i++)
            dp[i][j]=min(dp[i][j-1],dp[i+(1<<j-1)][j-1]);
}
//查询
int rmq(int l,int r){
    int k=log2(r-l+1);
    return min(dp[l][k],dp[r-(1<<k)+1][k]);
}
```



### ST表

#### 预处理O(n*log n) 用两个等长的小区间拼凑一个大区间 st[i] [j] 以第i个数为起点，长度为为2^j 的区间最值

$$
st[i][j]=max(st[i][j-1],st[i+2^(j-1)][j-1])
$$

```
int f[100005][22];

int main(){
  cin>>n>>m;
  for(int i=1;i<=n;i++) cin>>f[i][0];
  for(int j=1;j<=20;j++) //枚举区间长度
    for(int i=1;i+(1<<j)-1<=n;i++) //枚举起点
      f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
}
```

#### 查询O(1) 

```
for(int i=1,l,r;i<=m;i++){
	cin>>l>>r;
	int k=log2(r-l+1);
	cout<<max(f[l][k],f[r-(1<<k)+1][k])<<"\n";
	cout<<min(f[l][k],f[r-(1<<k)+1][k])<<"\n";
}
```



### 线段树：单次调用O(log n) 下标默认以1开始 (空间N<<2,防止RE)

#### 普通线段树

```
#define N 100005
#define LL long long
#define lc u<<1
#define rc u<<1|1
LL w[N];
struct Tree{ //线段树
  LL l,r,sum,add;
}tr[N*4];

void pushup(LL u){ //上传
  tr[u].sum=tr[lc].sum+tr[rc].sum;
}
void pushdown(LL u){ //下传
  if(tr[u].add){
    tr[lc].sum+=tr[u].add*(tr[lc].r-tr[lc].l+1),
    tr[rc].sum+=tr[u].add*(tr[rc].r-tr[rc].l+1),
    tr[lc].add+=tr[u].add,
    tr[rc].add+=tr[u].add,
    tr[u].add=0;      
  }
}
void build(LL u,LL l,LL r){ //建树
  tr[u]={l,r,w[l],0};
  if(l==r) return;
  LL m=l+r>>1;
  build(lc,l,m);
  build(rc,m+1,r);
  pushup(u);
}
void change(LL u,LL l,LL r,LL k){ //区修
  if(l<=tr[u].l&&tr[u].r<=r){
    tr[u].sum+=(tr[u].r-tr[u].l+1)*k;
    tr[u].add+=k;
    return;
  }
  LL m=tr[u].l+tr[u].r>>1;
  pushdown(u);
  if(l<=m) change(lc,l,r,k);
  if(r>m) change(rc,l,r,k);
  pushup(u);
}
LL query(LL u,LL l,LL r){ //区查
  if(l<=tr[u].l && tr[u].r<=r) return tr[u].sum;
  LL m=tr[u].l+tr[u].r>>1;
  pushdown(u);
  LL sum=0;
  if(l<=m) sum+=query(lc,l,r);
  if(r>m) sum+=query(rc,l,r);
  return sum;
}
int main(){
  int n,m,op,x,y,k;  
  cin>>n>>m;
  for(int i=1; i<=n; i ++) cin>>w[i];
  
  build(1,1,n);
  while(m--){
    cin>>op>>x>>y;
    if(op==2)cout<<query(1,x,y)<<endl;
    else cin>>k,change(1,x,y,k);
  }
  return 0;
}
```

#### 权值线段树

```
/*
权值线段树一般用于维护一段区间的数出现的次数，从它的定义来看，它可以快速计算出一段区间的数的出现次数。
在实际应用中，我们使用权值线段树查询区间第K大的值。
以数的大小为区间 数x要在[1,n]内
tree[rt] 插入数x 找到x在树中位置rt  次数数组tree[rt]++
*/
//单点更新
//类似基础线段树，递归到叶子节点+1然后回溯
void add(int l, int r, int rt, int x){
    if (l == r) tree[rt]++;
    else{
        int mid = (l + r) >> 1;
        if (x <= mid) add(l, mid, rt << 1, x);
        else add(mid + 1, r, rt << 1 | 1, x);
        tree[rt] = tree[rt << 1] + tree[rt << 1 | 1];
    }
}
//查询第K大
int query_kth(int pos, int l, int r, int k){ //如果K比右儿子大，就说明第K大的数在左子树中。然后，K要减去右子节点的值。
    if(l == r) return l;
    int mid = (l + r) >> 1, right = tree[pos << 1 | 1];
    if(k <= right) return query(pos << 1 | 1, mid + 1, r, k);
    else return query(pos << 1, l, mid, k - right);
}
//查询第K小
int query_kth(int pos, int l, int r, int k){
    if(l == r) return l;
    int mid = (l + r) >> 1, left = tree[pos << 1];
    if(k <= left) return query(pos << 1, l, mid, k - left);
    else return query(pos << 1 | 1, mid + 1, r, k);
}
//查询某个数出现次数
int find(int l, int r, int v, int x){
    if (l == r) return tree[v];
    else{
        int mid = (l + r) >> 1;
        if (x <= mid) return find(l, mid, v << 1, x);
        else return find(mid + 1, r, v << 1 | 1, x);
    }
}
//查询一段区间数出现的次数
int find(int l, int r, int v, int x, int y){
    if (l == x && r == y) return tree[v];
    else{
        int mid = (l + r) >> 1;
        if (y <= mid) return find(l, mid, v << 1, x, y);
        else if (x > mid) return find(mid + 1, r, v << 1 | 1, x, y);
        else return find(l, mid, v << 1, x, mid) + find(mid + 1, r, v << 1 | 1, mid + 1, y);
    }
}
//区间离散化
int get_discretization(){
    for (int i = 1; i <= n; ++i) a[i] = read(), b[i] = a[i]; //读入数据
    sort(b + 1, b + n + 1);
    int len = unique(b + 1, b + n + 1) - b - 1;
    for (int i = 1; i <= n; ++i){
        int pos = lower_bound(b + 1, b + len + 1, a[i]) - b;
        a[i] = pos;
    } //离散化
}
```

#### 可持久化线段树(主席树)

```
#define N 1e6+7
#define lc(x) tr(x).ch[0]
#define rc(x) tr(x).ch[1]
int n,m,a[N];
vector<int>v;
struct node{
	int ch[2];
	int s;//节点值域有多少个数
}tr[N*22];
int root[N],idx;
void build(int &x,int l,int r){//x为当前节点编号 x传引用
	x=++idx;
	if(l==r)return ;
	int mid=l+r>>1;
	build(lc(x),l,mid);
	build(rc(x),mid+1,r);
}
void insert(int x,int &y,int l,int r,int v){
	y=++idx;tr[y]=ty[x];tr[y].s++;
	if(l==r)return ;
	int mid=l+r>>1;
	if(v<=m) insert(lc(x),lc(y),l,mid,v);
	else insert(rc(x),rc(y),mmid+1,r,v);
}
```

### 莫队

```
/*一般来说，如果可以在 O(1) 内从 [l,r] 的答案转移到 [l-1,r] 、 [l+1,r] 、 [l,r-1] 、 [l,r+1] 这四个与之紧邻的区间的答案，则可以考虑使用莫队
转移分为两种情况，往区间里添数，或者往区间里删数，所以可以写成两个函数：del() , add()
*/
int ll,rr,bs;
lll res=0;// lll=long long 
struct node{
    int l,r;
    int id;
}p[N];
bool cmp(node a,node b){
    if(a.l/bs == b.l/bs) return a.r < b.r;
    return a.l < b.l;
}
lll cal(lll x){
    return 1ll*x*(x-1)/2;
}
void del(int x){
    cnt[x&1][a[x]]--;
    res -= (cnt[x&1][a[x]]);
}
void add(int x){
    res += (cnt[x&1][a[x]]);
    cnt[x&1][a[x]]++;
}
void slove(int i){
    while(ll < p[i].l) del(ll++);
    while(ll > p[i].l) add(--ll);
    while(rr < p[i].r) add(++rr);
    while(rr > p[i].r) del(rr--);
    ans[p[i].id] = cal(p[i].r - p[i].l + 1) - res;
}
signed main(){
   // ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    scanf("%lld%lld", &n, &q);
    bs = sqrt(n);
    for(int i = 1; i <= n; i++) {
       scanf("%lld", &a[i]);
        a[i]--;
        a[i] = a[i] ^ a[i-1];
    }
    for(int i = 1; i <= q; i++){
         scanf("%lld%lld", &p[i].l, &p[i].r);
        p[i].l--; //本题用的是异或和的前缀和 所以求[l,r]区间时 是用到 [l-1,r]
        p[i].id = i;
    }
    sort(p + 1, p + 1 + q, cmp);
    ll = 1, rr = 0;
    for(int i = 1; i <= q; i++){
        slove(i);
    }
    for(int i = 1; i <= q; i++) 
        printf("%lld\n",ans[i]);
    return 0; 
}
```

### 链表

#### 单链表：由值与指针构成，只能从前访问后一个节点 增删改查 删除先连后删 增删改均为O(1),查找为O(n)

#### 数组模拟：

```
const int N=200007;
int e[N],ne[N],head=-1,index;//e[i]表示节点i的值，ne[i]表示节点i的next指针的指向，head表示头节点下标(初始为-1)，idx存储当前节点
//头插
void insert_head(int x){
	e[index]=x;
	ne[index]=head;
	head=index++;
}
//在第k个数后插入
void insert(int k,int x){
	e[index]=x;
	ne[index]=ne[k];
	ne[k]=index++;
}
//删除第k个数
void Delete(int k){
	ne[k]=ne[ne[k]];
}
```

#### 单循环链表(最后一个节点链接第一个节点)

#### 双链表：含两个指针，既指前又指后

## 栈

#### 操作：

##### 1.压栈(push) :将数据插入栈顶

##### 2.弹栈(pop)：删除栈顶，返回该元素的值

##### 3.取栈(top):返回栈顶元素，但不删除

##### 4.判空(empty):bool类型

##### 5.判满(full):bool类型

##### 6.清空(clear)

##### 7.获取栈内元素个数(size)

##### 8.最小栈(getmin):用两个栈data min 实现

#### 类别：顺序栈：O(1) 链式栈

## 队列(先进先出)

#### 操作：

##### 1.入队(enqueue)

##### 2.出队(dequeue)

##### 3.队长(length)

##### 4.队首(front):返回队头元素，但不删除

##### 5.队尾(rear):返回队头元素，但不删除

##### 双端队列(dequeue)：STL

##### 优先队列(priority_queue)：STL

## 串(string)

#### 顺序串(数组)

#### 链式串(链表)

#### 朴素匹配：O(m*n)

### KMP(双指针) O(n+m)

#### next数组(对p模式串来求)：前面的字符串长度，前后缀最大匹配长度(不含整体)

```
//s文本串 p模式串 下标从1开始
const int N=1e6+7;
int ne[N];
char s[N],p[N];

void getnext(){
	ne[1]=0;
	for(int i=2,j=0;i<=n;i++){
		while(j&&p[i]!=p[j+1])j=ne[j];
		if(p[i]==p[j+1])j++;
		ne[i]=j;
	}
}
//s和p匹配
for(int i=1,j=0;i<=m;i++){
	while(j&&s[i]!=p[j+1])j=ne[j];
	if(s[i]==p[j+1])j++;
	if(j==n)cout<<i-n+1<<" ";
}
//Z函数 s与后缀的最长公共前缀长度
void get_z(char *s,int n){
	z[1]=n;
	for(int i=2,l,r=0;i<=n;i++){
		if(i<=r)z[i]=min(z[i-l+1],r-i+1);
		while(s[1+z[i]]==s[i+z[i]])z[i]++;
		if(i+z[i]-1>r)l=i,r=i+z[i]-1;
	}
}
//最小循环子串 n-next[n]
//如果len%(len-next[len])==0就说明有循环节，len-next[len]的值，就是s的最小循环节的长度，而len/（len-next[len]）就是最大循环次数！（其中len是字符串的长度）
```

### 最小表示法(找出字符串S的的循环同构串中字典序最小的一个)

```
const int N = 7e5;
int n;
int s[N];
int get_min(){
  for(int i=1;i<=n;i++) s[n+i]=s[i];
  int i = 1, j = 2;
  while(i<=n && j<=n){
    for(int k=0; k<n&&s[i+k]==s[j+k]; k++);
    s[i+k]>s[j+k] ? i=i+k+1 : j=j+k+1;
    if(i==j) j++;
  }
  return min(i, j);
}
```

### 字符串哈希

```
//不取模
#define BASE 37
#define PRIME 233317
long long gethash(char *s){
	long long n=strlen(s);
	long long hash=0;
	for(long long i=0;i<n;i++){
		hash=(hash*BASE+s[i])+PRIME;
	}
	return hash;
}

//取模
#define BASE 37
#define PRIME 233317
long long gethash(char *s,int mod){
	long long n=strlen(s);
	long long hash=0;
	for(long long i=0;i<n;i++){
		hash=(hash*BASE+s[i])%mod+PRIME;
	}
	return hash%mod;
}
```

###  Manacher算法(回文串)：O(n)

```
const int N=3e7;
char a[N],s[N];
int d[N]; //回文半径函数 
void get_d(char*s,int n){
  d[1]=1;
    for(int i=2,l,r=1;i<=n;i++){
        if(i<=r)d[i]=min(d[r-i+l],r-i+1);
        while(s[i-d[i]]==s[i+d[i]])d[i]++;
        if(i+d[i]-1>r)l=i-d[i]+1,r=i+d[i]-1;
    }  
}
int main(){
  //改造串
  scanf("%s",a+1);
  int n=strlen(a+1),k=0;
  s[0]='$',s[++k]='#'; //s[0]哨兵判断越界      
  for(int i=1;i<=n;i++) 
    s[++k]=a[i],s[++k]='#';
  n=k;
  get_d(s,n);//计算d函数
  int ans=0;
  for(int i=1;i<=n;i++)
    ans=max(ans,d[i]);
  printf("%d\n",ans-1);//原串的最长回文串是新串最大半径-1
  return 0;
}
```

### AC自动机(多模式匹配即n个模式串一个主串)

```
const int N=500010;
int n;char str[1000010];
int ch[N][26],cnt[N],idx;//ch[u][i]节点u的树边或转移边的终点
int ne[N]={0};//节点i的回跳边的终点
void insert(char *s){//建树
  int p=0;
  for(int i=0;s[i];i++){
    int j=s[i]-'a';
    if(!ch[p][j])ch[p][j]=++idx;
    p=ch[p][j];
  }
  cnt[p]++;
}
void build(){//建AC自动机 枚举u的26个儿子，若儿子存在，父亲帮儿子建立回调边，并将儿子入队 不存在，父亲自建转移边
  queue<int> q;
  for(int i=0;i<26;i++)
    if(ch[0][i])q.push(ch[0][i]);
  while(q.size()){
    int u=q.front();q.pop();
    for(int i=0;i<26;i++){
      int v=ch[u][i];
      if(v)ne[v]=ch[ne[u]][i],q.push(v);//回跳边
      else ch[u][i]=ch[ne[u]][i];//转移边
    }
  }
}
int query(char *s){
  int ans=0;//i走主串节点，不回退，j走回跳边
  for(int k=0,i=0;s[k];k++){
    i=ch[i][s[k]-'a'];
    for(int j=i;j&&~cnt[j];j=ne[j])
      ans+=cnt[j], cnt[j]=-1;
  }
  return ans;
}
```

### 后缀自动机

```
typedef long long LL;
const int N=2e6+10;
char str[N];
//邻接表
vector<int> e[N];
LL cnt[N],ans;
int tot=1,np=1;
//fa链接边终点,ch转移边终点,len最长串长度
int fa[N],ch[N][26],len[N];
void extend(int c){
  //p回跳指针, np新点, q链接点, nq新链接点
  int p=np; np=++tot;//p指向旧点, np是新点
  len[np]=len[p]+1; cnt[np]=1;//子串出现次数 
  //p沿链接边回跳，从旧点向新点建转移边
  for(;p&&!ch[p][c];p=fa[p])ch[p][c]=np;
  //1.如果c是新字符，从新点向根节点建链接边
  if(p==0)fa[np]=1;
  else{//如果c是旧字符
    int q=ch[p][c];//q是链接点
    //2.若链接点合法，从新点向q建链接边
    if(len[q]==len[p]+1)fa[np]=q;
    //3.若链接点不合法，则裂开q点，重建两类边
    else{
      int nq=++tot;//nq是新链接点
      len[nq]=len[p]+1;
      //重建nq,q,np的链接边
      fa[nq]=fa[q]; fa[q]=nq; fa[np]=nq;
      //指向q的转移边改为指向nq
      for(;p&&ch[p][c]==q;p=fa[p])ch[p][c]=nq;
      //从q发出的转移边复制给nq
      memcpy(ch[nq],ch[q],sizeof(ch[q]));
    }
  }
}
void dfs(int u){ 
  for(auto v : e[u]){
    dfs(v);
    cnt[u]+=cnt[v];
  }
  if(cnt[u]>1)ans=max(ans,cnt[u]*len[u]);
}
//链式前向星
struct edge{int v,ne;}e[N];
int h[N],idx;
LL cnt[N],ans;
int tot=1,np=1;
//fa链接边终点,ch转移边终点,len最长串长度
int fa[N],ch[N][26],len[N];
void extend(int c){
  //p回跳指针, np新点, q链接点, nq新链接点
  int p=np; np=++tot;//p指向旧点, np是新点
  len[np]=len[p]+1; cnt[np]=1;//子串出现次数
  //p沿链接边回跳，从旧点向新点建转移边
  for(;p&&!ch[p][c];p=fa[p])ch[p][c]=np;
  //1.如果c是新字符，从新点向根节点建链接边
  if(p==0)fa[np]=1;
  else{//如果c是旧字符
    int q=ch[p][c];//q是链接点
    //2.若链接点合法，从新点向q建链接边
    if(len[q]==len[p]+1)fa[np]=q;
    //3.若链接点不合法，则裂开q点，重建两类边
    else{
      int nq=++tot;//nq是新链接点
      len[nq]=len[p]+1;
      //重建nq,q,np的链接边
      fa[nq]=fa[q]; fa[q]=nq; fa[np]=nq;
      //指向q的转移边改为指向nq
      for(;p&&ch[p][c]==q;p=fa[p])ch[p][c]=nq;
      //从q发出的转移边复制给nq
      memcpy(ch[nq],ch[q],sizeof(ch[q]));
    }
  }
}
void add(int a,int b){
  e[++idx]={b,h[a]};
  h[a]=idx;
}
void dfs(int u){ 
  for(int i=h[u];i;i=e[i].ne){
    int v=e[i].v;
    dfs(v);
    cnt[u]+=cnt[v];
  }
  if(cnt[u]>1)ans=max(ans,cnt[u]*len[u]);
}
sigen main(){
  scanf("%s",str);
  for(int i=0;str[i];i++)extend(str[i]-'a');
  for(int i=2;i<=tot;i++)add(fa[i],i);
  dfs(1);
  printf("%lld\n",ans);
}
```

### 后缀数组 O(n)

```
const int N = 2000010;
char s[N];
int n, m;//n为后缀个数, m为桶的个数
int x[N], y[N], c[N], sa[N], rk[N], height[N];
//桶数组x[i],辅助数组y[i],计数数组c[i]
void get_sa() {
    int i, j, k;
    //按第一个字母排序
    for (i = 1; i <= n; i++)c[x[i] = s[i]]++;
    for (i = 1; i <= m; i++)c[i] += c[i - 1];
    for (i = n; i; i--)sa[c[x[i]]--] = i;
    for (k = 1; k <= n; k <<= 1) { //logn轮
        //按第二关键字排序
        memset(c, 0, sizeof(c));
        for (i = 1; i <= n; i++)y[i] = sa[i];
        for (i = 1; i <= n; i++)c[x[y[i] + k]]++;
        for (i = 1; i <= m; i++)c[i] += c[i - 1];
        for (i = n; i; i--)sa[c[x[y[i] + k]]--] = y[i];
        //按第一关键字排序
        memset(c, 0, sizeof(c));
        for (i = 1; i <= n; i++)y[i] = sa[i];
        for (i = 1; i <= n; i++)c[x[y[i]]]++;
        for (i = 1; i <= m; i++)c[i] += c[i - 1];
        for (i = n; i; i--)sa[c[x[y[i]]]--] = y[i];
        //把后缀放入桶数组
        for (i = 1; i <= n; i++)y[i] = x[i];
        for (m = 0, i = 1; i <= n; i++)
            if (y[sa[i]] == y[sa[i - 1]] &&
                y[sa[i] + k] == y[sa[i - 1] + k])x[sa[i]] = m;
            else x[sa[i]] = ++m;
        if (m == n)break;//已排好    
    }
}
void get_height() {
    int i, j, k;
    for (i = 1; i <= n; i++)rk[sa[i]] = i;
    for (i = 1, k = 0; i <= n; i++) { //枚举后缀i
        if (rk[i] == 1)continue;//第一名height为0
        if (k)k--;//上一个后缀的height值减1
        int j = sa[rk[i] - 1];//找出后缀i的前邻后缀j
        while (i + k <= n && j + k <= n && s[i + k] == s[j + k])k++;
        height[rk[i]] = k;
    }
}
int main() {
    scanf("%s", s + 1);
    n = strlen(s + 1); m = 122;
    get_sa();
    get_height();
    for (int i = 1; i <= n; i++)printf("%d ", sa[i]);
    // puts("");
    // for(int i=1;i<=n;i++)printf("%d ",height[i]);
    return 0;
}
```

### 前后缀字典序排列

```
给出某一序列，求按字典序排列的前一序列
bool cmp(int x,int y){
	return x>y;
}
string getpre(string str){
	int n=str.length();
	bool judge=false;	//用于判断序列是否存在 ，也可返回
	string s=str; 
	int i,j;
	for(i=n-2;i>=0;i--){
		if(s[i]>s[i+1]){
			judge=true;
			break;
		}
	}
	for(j=n-1;j>i;j--) if(s[j]<s[i]) break;
	char tmp=s[i];
	s[i]=s[j],s[j]=tmp;
	sort(s.begin()+i+1,s.end(),cmp);
	return s;
}
求按字典序排列的后一序列
string getpro(string str){
	int n=str.length();
	bool judge=false;	//用于判断序列是否存在 ，也可返回
	string s=str; 
	int i,j;
	for(i=n-2;i>=0;i--){
		if(s[i]<s[i+1]){
			judge=true;
			break;
		}
	}
	for(j=n-1;j>i;j--) if(s[j]>s[i]) break;
	char tmp=s[i];
	s[i]=s[j],s[j]=tmp;
	sort(s.begin()+i+1,s.end());
	return s;
}
```

### 滑动窗口/单调队列：维持左右边界不回退的范围 求解子数组问题

```
const int N=1e6+7;
int n,k;//k 窗口大小
int a[N],idx[N];//输入数组 下标数组

void solve() {
    std::cin>>n>>k;
    for(int i=1;i<=n;i++){
        std::cin>>a[i];
    }
    int h=1,t=0;
    for(int i=1;i<=n;i++){
        while(h<=t&&a[idx[t]]>=a[i]){//getmin 
            t--;//队尾出队
        }
        idx[++t]=i;
        if(idx[h]<i-k+1){
            h++;//队头出队
        }
        if(i>=k){
            std::cout<<a[idx[h]]<<" ";
        }
    }
    std::cout<<'\n';
    h=1,t=0;
    for(int i=1;i<=n;i++){
        while(h<=t&&a[idx[t]]<=a[i]){//getmax
            t--;
        }
        idx[++t]=i;
        if(idx[h]<i-k+1){
            h++;
        }
        if(i>=k){
            std::cout<<a[idx[h]]<<" ";
        }
    }
}

  // 维护窗口最小值
  q.clear();                              //清空队列
  for(int i=1; i<=n; i++){                //枚举序列
    while(!q.empty() && a[q.back()]>=a[i]) q.pop_back(); //队尾出队(队列不空且新元素更优)
    q.push_back(i);                       //队尾入队(存储下标 方便判断队头出队)          
    while(q.front()<i-k+1) q.pop_front(); //队头出队(队头元素滑出窗口)
    if(i>=k) printf("%d ",a[q.front()]);  //使用最值   
  }
  puts("");
  
  // 维护窗口最大值
  q.clear();
  for(int i=1; i<=n; i++){
    while(!q.empty() && a[q.back()]<=a[i]) q.pop_back();
    q.push_back(i);
    while(q.front()<i-k+1) q.pop_front();
    if(i>=k) printf("%d ",a[q.front()]);
  }
```

### 双指针O(n)：

#### 快慢指针(滑动窗口)：快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后

```
int finrDuplicate(vector<int>&nums){
	if(nums.size()<2)return -1;
	int slow=nums[0];
	int fast=nums[nums[0]];
	while(slow!=fast){
		slow=nums[slow];
		fast=nums[nums[fast]];
	}
	fast=0;
	while(slow!=fast){
		slow=nums[slow];
		fast=nums[fast];
	}
	return slow;
}
```

#### 左右指针：两个指针 `left`、`right` 分别指向序列第一个元素和最后一个元素，然后 `left` 指针不断递增，`right` 不断递减，直到两个指针的值相撞（即 `left == right`），或者满足其他要求的特殊条件为止

```
int trap(vector<int>&nums){
	int l=1,r=nums.size()-2,lmax=nums[0],rmax=nums[nums.size()-1];
	int ans=0;
	while(l<=r){
		if(lmax<=rmax){
		ans+=max(0,lmax-nums[1]);
		lmax=max(lmax,nums[l++]);
		}
		else {
			ans+=max(0,rmax-nums[r]);
			rmax=max(rmax,nums[r--]);
		}
	}
	return ans;
}
```

### 单调栈O(n)：

##### 栈中元素是下标

##### 单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小

##### 单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大

##### 现在有一组数10，3，7，4，12。从左到右依次入栈，则如果**栈为空**或**入栈元素值小于栈顶元素值**，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。

```
int arr[5]={10,3,7,4,12};
stack<int>st;//单增
for(int i=0;i<5;i++){
	if(st.empty()||st.top()>arr[i])st.push(arr[i]);
	else {
		while(!st.empty()&&st.top()<=arr[i]){
			int top=st.top();
			st.pop();
		}
		st.push(arr[i]);
	}
}
cout<<st.top();
```

## 树

#### 二叉树：

##### 遍历(根的遍历顺序)：

###### 1.前序遍历：根->左->右

###### 2.中序遍历：左->根->右

###### 3.后序遍历：左->右->根

##### 二叉搜索树(二叉排序树)：左子树结点值<根子树结点值<右子树结点值(中序遍历即递增有序序列)

##### 平衡二叉树(二叉搜索树)：左子树与右子树高度差不超过一

#### 红黑树

##### 哈夫曼树：wpl所有叶子结点的带权路径之和

#### 字典树(前缀树):trie 树的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

```
//根节点编号为0
int t[N][65],cnt[N],idx;//儿子数组 计数数组 节点编号
int getnum(char x){
    if(x>='A'&&x<='Z')
        return x-'A';
    else if(x>='a'&&x<='z')
        return x-'a'+26;
    else
        return x-'0'+52;
} 
void insert(std::string s){
    int p=0;
    for(int i=0;i<s.size();i++){
        int c=getnum(s[i]);//c=s[i]-'a'
        if(!t[p][c])
            t[p][c]=++idx;
        p=t[p][c];
      cnt[p]++;
    }
}
int find(std::string s){
    int p=0;
    for(int i=0;i<s.size();i++){
        int c=getnum(s[i]);//c=s[i]-'a'
        if(!t[p][c])
          return 0;
        p=t[p][c];
    }
    return cnt[p];
}
```

#### 01字典树：n个数进行异或(二进制)，求最大结果

```
// 01Trie 最大异或对
const int N=100010;
int n, a[N];
int ch[N*31][2],cnt;
void insert(int x){
  int p=0;
  for(int i=30; i>=0; i--){
    int j=x>>i&1; //取出第i位
    if(!ch[p][j])ch[p][j]=++cnt;
    p=ch[p][j];
  }
}
int query(int x){
  int p=0,res=0;
  for(int i=30; i>=0; i--){
    int j=x>>i&1;
    if(ch[p][!j]){
      res += 1<<i; //累加位权
      p=ch[p][!j];
    }
    else p=ch[p][j];
  }
  return res;
}
int main(){
  cin>>n;
  for(int i=1; i<=n; i++)
    cin>>a[i],insert(a[i]);
  int ans=0;
  for(int i=1; i<=n; i++)
    ans=max(ans,query(a[i]));
  cout<<ans;
  return 0;
}
```

#### 树的重心：指树中的一个节点，在这个节点删除后，剩余各个连通块中心点的最大值最小

```
void dfs(int x){
	vis[x]=1;
	size[x]=1;//子树x的大小
	int max_part=0;//删掉x后分成的最大子树的大小
	for(int i=head[i];i;i=next[i]){
		int y=ver[i];
		if(vis[y])continue;
		dfs(y);
		size[x]+=size[y];
		max_part=max(max_part,size[y]);
		max_part=max(max_part,n-size[x]);
		if(max_part<ans){
			ans=max_part;
			pos=x;//重心
		}
	}
}
```

#### 树的直径:节点最长和次长之和

```
const int N=10010,M=20010;
int n,a,b,c,ans;
struct edge{int v,w;};
vector<edge> e[N];

int dfs(int x,int fa){
  int d1=0,d2=0;//d1最大长度 d2次大长度 
  for(auto ed : e[x]){
    int y=ed.v, z=ed.w;
    if(y==fa) continue;
    int d=dfs(y,x)+z;
    if(d>=d1) d2=d1,d1=d;
    else if(d>d2) d2=d;
  }
  ans=max(ans,d1+d2);
  return d1;
}
int main(){
  cin>>n;
  for(int i=1; i<n; i++){
    cin>>a>>b>>c;
    e[a].push_back({b,c});
    e[b].push_back({a,c});
  }
  dfs(1,-1);
  cout<<ans;
}
```

#### 中心：节点到其他节点最远距离最近

```
const int N=20010;
int n,a,b,c,ans=2e9;
struct edge{int v,w;};
vector<edge> e[N];
int d1[N],d2[N],path[N],up[N];

void dfs(int x,int fa){//向下走 d1最长 d2次长
  for(auto ed : e[x]){
    int y=ed.v, z=ed.w;
    if(y==fa) continue;
    dfs(y, x);
    if(d1[y]+z>d1[x]) 
      d2[x]=d1[x],d1[x]=d1[y]+z,path[x]=y;
    else if(d1[y]+z>d2[x]) d2[x]=d1[y]+z;
  }
}
void dfs2(int x,int fa){//向上走
  for(auto ed : e[x]){
    int y=ed.v, z=ed.w;
    if(y==fa) continue;
    if(y==path[x])up[y]=max(up[x],d2[x])+z;
    else up[y]=max(up[x],d1[x])+z;
    dfs2(y, x);
  }
}
int main(){
  cin>>n;
  for(int i=1; i<n; i++){
    cin>>a>>b>>c;
    e[a].push_back({b,c});
    e[b].push_back({a,c});
  }
  dfs(1, 0);
  dfs2(1, 0);
  for(int i=1; i<=n; i++)
    ans=min(ans,max(d1[i],up[i]));
  cout<<ans;
}
```

## 散列表(hash)

### 哈希函数

$$
hash[s]=\sum_{i=1}^{i=n}s[i]*p^{n-i}(mod M)
$$

### 滚动哈希

```
int gethash(int l,int r){
	return hash[r]-hash[l-1]*p[r-l+1];
}
//判重
bool substr(int ,l1,int r1,int l2,int r2){
	return gethash(l1,r1)==gethash(l2,r2); 
}
```

### 树哈希

```
ll h(ll x){
	return x*x*x*x*1237123+19260817;
}
ll f(ll x){
	ll cur=h(x&((1<<31)-1))+h(x>>31);
	return cur;
}
```

## 图论

### 领接表(vector)/邻接矩阵(N较小 1000及以下)：无向图(对称矩阵)

```
//邻接矩阵 邻接表
int n, m;
int graph[1005][1005];//邻接矩阵
vector<int> e[1005];//邻接表
int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u][v] = 1;
        graph[v][u] = 1;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    //打印邻接矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << graph[i][j] << " ";
        }
        cout << "\n";
    }
    //打印邻接表
    for (int i = 1; i <= n; i++) {
        cout << e[i].size() << " ";
        sort(e[i].begin(), e[i].end());
        for (int j = 0; j < e[i].size(); j++) {
            cout << e[i][j] << " ";
        }
        cout << "\n";
    }
    return 0;
}
```

### 链式前向星(固定数组的邻接表即用数组模拟链表)：O(n)  无向图开两倍数组

```
const int maxn = 1005;//点数最大值
int n, m, cnt=0;//n个点，m条边
struct Edge
{
    int to, w, next;//终点，边权，同起点的上一条边的编号
}edge[maxn];//边集
int head[maxn];//head[i],表示以i为起点的第一条边在边集数组的位置（编号）
void add_edge(int u, int v, int w)//加边，u起点，v终点，w边权
{
    edge[cnt].to = v; //终点
    edge[cnt].w = w; //权值
    edge[cnt].next = head[u];//以u为起点上一条边的编号，也就是与这个边起点相同的上一条边的编号
    head[u] = cnt++;//更新以u为起点上一条边的编号
}
int main()
{
    cin >> n >> m;
    int u, v, w;
    memset(head, -1, sizeof(head));//初始化
    for (int i = 1; i <= m; i++)//输入m条边
    {
        cin >> u >> v >> w;
        add_edge(u, v, w);//加边
        /*
        加双向边
        add_edge(u, v, w);
        add_edge(v, u, w);
        */
    }
    for (int i = 1; i <= n; i++)//n个起点
    {
        cout << i << endl;
        for (int j = head[i]; j != -1; j = edge[j].next)//遍历以i为起点的边
        {
            cout << i << " " << edge[j].to << " " << edge[j].w << endl;
        }
        cout << endl;
    }
    return 0;
}
```

### 搜索

#### BFS和DFS模板：

```
//dfs
vector<int>e[N];
bool vis[N];
void dfs(int u){
	vis[u]=1;
	for(auto v:e[u]){
		if(vis[v])continue;
		dfs(v);
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1);
	return 0;
}

//bfs
vector<int>e[N];
bool vis[N];
queue<int>q;//pair<int,int>或者tuple<int,int ,int>
void bfs(){
	vis[1]=1;
	q.push(1);
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int y:e[x]){
			if(vis[y])continue;
			vis[y]=1;
			q.push(y);
		}
	}
}

p[N],q[N];//p撇对角线 下标（i+J）q捺对角线 下标（i-j+n） 
```

##### 01bfs 边权只有0和1 w=0头插 w=1尾插

```
void solve() {
    while(std::cin>>n>>m&&n!=0&&m!=0){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++)
                std::cin>>a[i][j];
    }
        int x1,y1,x2,y2;//起点 终点
        std::cin>>x1>>y1>>x2>>y2;
        x1++,y1++,x2++,y2++;
        std::deque<node>q;
        memset(vis,0,sizeof vis);
        q.push_back((node){x1,y1,0,a[x1][y1]});
        vis[x1][y1]=1;
        while(q.size()){
            node w=q.front();
            q.pop_front();
            if(w.x==x2&&w.y==y2){
                std::cout<<w.z<<"\n";
                break;
            }
            for(int i=0;i<4;i++){
                int xx=w.x+dx[i];
                int yy=w.y+dy[i];
                if(xx>n||yy>m||xx<1||yy<1||vis[xx][yy])
                    continue;
                vis[xx][yy]=1;
                if(a[xx][yy]==w.c)
                    q.push_front({xx,yy,w.z,w.c});
                else 
                    q.push_back((node){xx,yy,w.z+1,a[xx][yy]});
            }
        }
    }
}
```

##### 树的DFS序：每个节点刚进入递归后以及即将回溯前各记录一次，最后长度为2N的序列 维护子树关系(u v v是u的某个儿子节点，有lu<=lv<=rv<=ru) 可以将树上的数映射到树状数组上

```
void dfs(int x,int pre,int d){//L,R表示一个子树的范围
    L[x]=++tot;
    dep[x]=d;
    for(int i=0;i<e[x].size();i++){
        int y=e[x][i];
        if(y==pre)continue;
        dfs(y,x,d+1);
    }
    R[x]=tot;
}
//树扁平化映射树状数组
void dfs(int u, int fa) {
    st[u] = ++timer;             
    newtree[timer] = val[u];   
    for (int i : tree[u]) {
        if (i != fa) {
            dfs(i, u);
        }
    }
    ed[u] = timer;               
}
```

### 拓扑排序(有向无环图)：删掉入度为0的点 再删掉其影响 重复操作并依次输出顺序即拓扑排序顺序

```
//Kahn算法 bfs
vector<int>e[N],tp;
int din[N];

bool toposort(){
	queue<int>q;
	for(int i=1;i<=n;i++){
		if(din[i]==0)
			q.push(i);
	}
	while(!q.empty()){
		int x=q.front();
		q.pop();
		tp.push_back(x);
		for(auto y:e[x]){
			if(--din[y]==0)
				q.push(y);
		}
	}
	return tp.size()==n;
}
signed main(){
	cin>>n>>m;
	for(int i=0;i<m;i+){
		cin>>a>>b;
		e[a].push_back(b);
		e[b].push_back(a);
		din[b]++;
	}
	if(!toposort())cout<<-1<<'\n';
	else for(auto x:tp)cout<<x<<" ";
	return 0;
}
//dfs
vector<int>e[N],tp;
int c[N];//染色数组  0--->-1--->1

bool dfs(int u){
	c[u]=-1;
	for(int y:e[u]){
		if(c[y]<0)return 0;//有环
		else if(!c[y])
			if(!dfs(y))return 0;
	}
	c[u]=1;
	tp.push_back(u);
	return 1;
}
bool toposort(){
	memset(c,0,sizeof c);
	for(int i=1;i<=n;i++){
		if(!c[i])
			if(!dfs(i))return 0;
	}
	reverse(tp.begin(),tp.end());//tp为逆拓扑序
	return 1;
}
signed main(){
  cin >> n >> m;
  for(int i=0; i<m; i++){
    cin >> a >> b;
    e[a].push_back(b);
  }
  if(!toposort()) puts("-1");
  else 
    for(int x:tp)printf("%d ",x);
  return 0;
}
```

### 最短路：

![image-20240702171851907](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240702171851907.png)

#### Dijkstra算法(有向图且权值非负)：

```
// 朴素
int n, m, s, a, b, c;
const int N = 100010;  // 最大节点数
struct edge { int v, w; };  // 边的结构体，v表示邻接点，w表示权重
vector<edge> e[N];  // 邻接表存储图
int d[N], vis[N];  // d[]用于存储源点到各个节点的最短路径，vis[]用于标记节点是否已经确定最短路径
// Dijkstra算法
void dijkstra(int s) {
  // 初始化最短路径为无穷大
  for (int i = 0; i <= n; i++) d[i] = inf;
  d[s] = 0;  // 起点的最短路径为0
  // 执行n-1次（最多需要n-1次迭代来找到所有点的最短路径）
  for (int i = 1; i < n; i++) {
    int u = 0;  // 记录当前最短路径的点
    // 遍历所有节点，选择一个未标记的，且最短路径最小的节点u
    for (int j = 1; j <= n; j++) {
      if (!vis[j] && d[j] < d[u]) u = j;  // 如果节点j未标记且d[j]小于d[u]，更新u
    }
    vis[u] = 1;  // 将节点u标记为已确定最短路径
    // 遍历节点u的所有邻边
    for (auto ed : e[u]) {
      int v = ed.v, w = ed.w;  // v为邻接点，w为边的权重
      // 如果通过u到v的路径比原来的路径短，更新d[v]
      if (d[v] > d[u] + w) {
        d[v] = d[u] + w;
      }
    }
  }
}

//堆优化 O(n*log n)
//堆优化Dijkstra 
const int N=100010;
int n,m,s,a,b,c;
struct edge{int v,w;};
vector<edge> e[N];
int d[N],vis[N];

void dijkstra(int s){
  memset(d,0x3f,sizeof d); d[s]=0; 
  priority_queue<pair<int,int>> q;
  q.push({0,s});
  while(q.size()){
    auto t=q.top(); q.pop();
    int u=t.second;
    if(vis[u])continue; //再出队跳过
    vis[u]=1; //标记u已出队
    for(auto ed : e[u]){
      int v=ed.v, w=ed.w;
      if(d[v]>d[u]+w){
        d[v]=d[u]+w;
        q.push({-d[v],v}); //大根堆
      }
    }
  }
}
//输出路径
void dfs_path(int u){
	if(u==s){
		cout<<u<<" ";return ;
	}
	dfs_path(pre[u]);
	cout<<u<<" ";
}
int main(){
  cin>>n>>m>>s;
  for(int i=0; i<m; i++)
    cin>>a>>b>>c, e[a].push_back({b,c});
  dijkstra(s);
  for(int i=1;i<=n;i++) printf("%d ",d[i]); 
}
```

#### Bellman-Frod算法：O(n*m)可以用队列优化即spfa

```
const int N=1e6+7,inf=0x3f3f;
struct edge{
	int v,w;
};
vector<edge>e[N];
int d[N],pre[N];

//输出路径
void dfs_path(int u){
	if(u==s){
		cout<<u<<" ";return ;
	}
	dfs_path(pre[u]);
	cout<<u<<" ";
}

bool bellmanford(int s){
	memset(d,inf,sizeof d);
	d[s]=0;
	bool flag;//松弛标记
	for(int i=1;i<=n;i++){
		flag=0;
		for(int u=1;u<=n;u++){
			if(d[u]==inf)continue;
			for(auto ed:e[u]){//u的出边
				int v=ed.v,w=ed.w;
				if(d[v]>d[u]+w){
					d[v]=d[u]+w;
					flag=1;
				}
			}
		}
		if(!flag)break;
	}
	return flag;//第n轮=1即有环
}
```

#### Spfa算法：O(n*m)

```
const int N=1e5+10;
int e[N],ne[N],w[N],h[N],idx;
void add(int a,int b,int c){//邻接表
	e[idx]=b;
	w[idx]=c;
	ne[idx]=h[a];
	h[a]=idx++;
}
int spfa(){
	memset(dist,0x3f3f3f,sizeof dist);
	dist[0]=1;
	queue<int>q;
	q.push(1);
	st[1]=true;
	while(q.size()){
		int t=q.front();
		q.pop();
		st[t]=false;
		for(int i=h[t];i!=-1;i=ne[i]){
			int j=e[i];
			if(dist[j]>dist[t]+w[i]){
				dist[j]=dist[t]+w[i];
				if(!st[j]){
					q.push(j);
					st[j]=true;
				}
			}
		}
	}
}
```

####  Floyd算法：

![image-20240702203559188](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240702203559188.png)

```
int g[N][N],p[N][N];
void Folyd(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j)g[i][j]=0;
			else g[i][j]=INF;
		}
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
				p[i][j]=k;
			}
		}
	}
}
void dfs_path(int i,int j){
	if(g[i][j]==0)return ;
	int k=p[i][j];
	dfs_path(i,k);
	cout<<k<<" ";
	dfs_path(k,j);
}

```

#### Johnson算法(很少)：O(n**m*log m)建虚拟源点O，跑spfa和dj 

```
#define N 30010
#define INF 1000000000
using namespace std;

int n,m,a,b,c;
struct edge{int v,w;};
vector<edge> e[N];
int vis[N],cnt[N];
long long h[N],d[N];

void spfa(){
    queue<int>q;
    memset(h,63,sizeof h);
    memset(vis,false,sizeof vis);
    h[0]=0,vis[0]=1;q.push(0);
    while(q.size()){
        int u=q.front(); q.pop();vis[u]=0;
        for(auto ed : e[u]){
            int v=ed.v,w=ed.w;
            if(h[v]>h[u]+w){
                h[v]=h[u]+w;
        cnt[v]=cnt[u]+1;
        if(cnt[v]>n){
          printf("-1\n");exit(0);
        }
                if(!vis[v])q.push(v),vis[v]=1;
            }
        }
    }
}
void dijkstra(int s){
    priority_queue<pair<long long,int>>q;
    for(int i=1;i<=n;i++)d[i]=INF;
    memset(vis,false,sizeof vis);
    d[s]=0; q.push({0,s});
    while(q.size()){
        int u=q.top().second;q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto ed : e[u]){
            int v=ed.v,w=ed.w;
            if(d[v]>d[u]+w){
                d[v]=d[u]+w;
                if(!vis[v]) q.push({-d[v],v});
            }
        }
    }
}
int main(){
  cin>>n>>m;
  for(int i=0;i<m;i++)
    cin>>a>>b>>c, e[a].push_back({b,c});
    for(int i=1;i<=n;i++)
      e[0].push_back({i,0});//加虚拟边
    spfa();
    for(int u=1;u<=n;u++)
      for(auto &ed:e[u])
        ed.w+=h[u]-h[ed.v];//构造新边
    for(int i=1;i<=n;i++){
        dijkstra(i);
        long long ans=0;
        for(int j=1;j<=n;j++){
            if(d[j]==INF) ans+=(long long)j*INF;
            else ans+=(long long)j*(d[j]+h[j]-h[i]);
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

### 并查集：均摊O(1)

```
//初始化
const int MAXN = 1000001;
int fa[MAXN],Size[MAXN],help[MAXN];
int n;
void build() {
    for (int i = 0; i <= n; i++) {
        fa[i] = i;
        Size[i] = 1;
    }
}
```

#### 1.find 

##### 	扁平化

```
int find(int i){
	if(i!=fa[i])
	fa[i]=find(fa[i]);
	return fa[i];
}
//带收集路径点的扁平化
int find(int i){
	int top=0;//top收集点的数量
	while(i!=fa[i]){
		help[top++]=i;//将i装进help里
		i=fa[i];//继续向上走
	}
	while(top>0){
		fa[help[--top]]=i;
	}
	return i;
}
    auto find = [&](auto &&self,int x) -> int {
        if(x!=fa[x])fa[x]=self(self,fa[x]);
        return fa[x];
    };
```

#### 2.issameset

```
//x,y是否在同一个集合
bool isSameSet(int x, int y) {
	return find(x) == find(y);
}
//x,y本来是一个集合返回0，本来不是合并后是一个集合返回1
bool isSameSet(int x,int y){
	int fx=find(x),fy=find(y);
	if(fx!=fy){
		fa[fx]=fy;
		return 1;
	}
	else return 0;
}
```

#### 3.union

```
void Union(int x,int y){
	fa[find(x)]=find(y);
}
//小的挂在大的上
void Union(int x,int y){
	int fx=find(x),fy=find(y);
	if(fx!=fy){
		if(Size[fx]>Size[fy]){
			Size[fx]+=Size[fy];
			fa[fy]=fx;
		}
		else {
			Size[fy]+=Size[fx];
			fa[fx]=fy;
		}
	}
}
    auto merge=[&](int fx,int fy){
        fx=find(find,fx),fy=find(find,fy);
        if(fx==fy)return;
        if(fx<fy)
            std::swap(fx,fy);
        sum[fx]+=sum[fy];
        sz[fx]+=sz[fy];
        fa[fy]=fx;
    };
```

#### 离散化：

##### 1.排序

##### 2.去重(unique)

##### 3.二分索引

```
int get(int i){
	int l=-1,r=a.size();
	while(l+1!=r){
		int mid=l+(r-l)>>1;
		if(a[mid]<i)l=mid;
		else r=mid;
	}
	return r;
}
sort(a.begin(),a.end());
a.erase(unique(a.begin(),a.end()),a.end());
sort(tot,tot+n,cmp);
for(int i=0;i<a.size();i++)fa.push_back(i);
for(int k=0;k<n;k++){
	int i=tot[k].i,j=tot[k].j,e=tot[k].e;
	i=get(i),j=get(j);//找到离散化后对应的下标
	if(e==i)Union(i,j);//e==1,将两个集合合并
	else {
		if(find(i)==find(j))flag=0;//e==0且xi和xj在一个集合，约束不成立
	}
}
```

#### 拓展：

##### 集合的标签：设置集合的一些属性

### 最小生成树：无向带权图 n-1条边

#### 1. Kruskal算法---------并查集  时间复杂度O(m * log m) + O(n + m)

![image-20240527102425337](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240527102425337.png)

```
const int N=200006;
int n, m;
struct edge{
  int u,v,w;
  bool operator<(const edge &t)const
  {return w < t.w;}   
}e[N];
int fa[N],ans,cnt;

int find(int x){
  if(fa[x]==x) return x;
  return fa[x]=find(fa[x]);
}
bool kruskal(){
  sort(e,e+m);
  for(int i=1;i<=n;i++)fa[i]=i;
  for(int i=0; i<m; i++){
    int x=find(e[i].u);
    int y=find(e[i].v);
    if(x!=y){
      fa[x]=y;
      ans+=e[i].w;
      cnt++;
    }
  } 
  return cnt==n-1;
}
```

#### 2.Prim算法-----------堆 时间复杂度O(m * log m) + O(n + m)

![image-20240529200428451](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240529200428451.png)

```
//朴素
struct edge{int v,w;};
vector<edge>e[N];
int d[N],vis[N];
int ans,cnt;
bool prim(int s){
	memset(d,inf,sizeof d);
	d[s]=0;
	for(int i=1;i<=n;i++){
		int u=0;
		for(int j=1;j<=n;j++){
			if(!vis[j]&&d[j]<d[u])d=j;
		}
		vis[u]=1;//标记u点出圈
		ans+=d[u];
		if(d[u]!=inf)cnt++;
		for(auto ed:e[u]){
			int v=ed.v,w=ed.w;
			if(d[v]>w)d[v]=w;
		}
	}
	return cnt==n;
}

//堆优化
const int N=5010;
int n,m,a,b,c,ans,cnt;
struct edge{int v,w;};
vector<edge> e[N];
int d[N], vis[N];
priority_queue<pair<int,int>> q;
        
bool prim(int s){
  for(int i=0;i<=n;i++) d[i]=inf;
  d[s]=0; q.push({0,s});
  while(q.size()){
    int u=q.top().second; q.pop();
    if(vis[u])continue;//再出队跳过
    vis[u]=1;//标记u已出队
    ans+=d[u]; cnt++;
    for(auto ed : e[u]){
      int v=ed.v, w=ed.w;
      if(d[v]>w){
        d[v]=w;
        q.push({-d[v],v});//大根堆
      }
    }
  }
  return cnt==n;
}
```

### 欧拉路与欧拉回路

#### 判断一个图是否存在欧拉路

##### 1.无向图：连通图中，若奇数数度节点个数为0或2，则存在欧拉路。

##### 2.有向图：连通图中，若出度比入度大1的节点和入度比出度大1的节点都为1或0，则存在欧拉路。

#### 判断一个图是否存在欧拉回路

##### 1.无向图：连通图中，若每个顶点的度数都是偶数，则存在欧拉回路。

##### 2.有向图：连通图中，若每个顶点的入度都等于出度，则存在欧拉回路。

```
Fleury算法
void dfs( int u ) {
    sta.push(u);
    for( register int i = head[u]; i; i = line[i].nxt ) {
        if( vis[i] ) continue;
        vis[i] = vis[ i ^ 1 ] = true;
        dfs( line[i].to );
        break;
    }
}

void fleury( int st ) {
    sta.push(st);
    while(!sta.empty() ) {
        int flag = 0, u = sta.top(); sta.pop();
        for( register int i = head[u]; i; i = line[i].nxt) {
            if( vis[i] ) continue;
            flag = 1; break;
        }
        if( !flag ) printf( "%d\n", u );
        else        dfs(u);
    }
}
```

### 二分图

##### 最大匹配数：最大匹配的匹配边的数目

##### 最小顶点覆盖数：选取最少的点，使任意一条边至少有一个端点被选择，满足该集合的点的数目

##### 最大独立集数：选取最多的点，使任意所选两点均不相连，满足该集合的点的数目

##### 最小边覆盖数：选取最少条路径，使得每个顶点属于至少是其中某条边的端点，满足该集合的边的数目。

##### 定理1：二分图中，最大匹配数 = 最小点覆盖数 定理2：最大独立数+最小点覆盖数=顶点数 定理3：对于不存在孤立点的图，最小边覆盖数+最大匹配数= 顶点数

#### 匈牙利算法

```
求最大匹配数
int girl[MAXN];
bool line[MAXN][MAXN],used[MAXN];
int n,m;
主函数：
bool find(int x){
	int ij;
	for (j=1;j<=m;j++){    //扫描每个妹子
		if (line[x][j]==true && used[j]==false){      
		//如果有暧昧并且还没有标记过(这里标记的意思是这次查找曾试图改变过该妹子的归属问题，但是没有成功，所以就不用瞎费工夫了）
			used[j]=true;
			if (girl[j]==0 || find(girl[j])) { 
				//名花无主或者能腾出个位置来，这里使用递归
				girl[j]=x;
				return true;
			}
		}
	}
	return false;
}
主程序：
for (i=1;i<=n;i++){
	memset(used,false,sizeof(used));
	if find(i) all+=1;
}
```

#### KM算法

```
求二分图最大权完美匹配
#define MAXN 305;
#define INF 0x3f3f3f3f
 
int love[MAXN][MAXN];   // 记录每个妹子和每个男生的好感度
int ex_girl[MAXN];      // 每个妹子的期望值
int ex_boy[MAXN];       // 每个男生的期望值
bool vis_girl[MAXN];    // 记录每一轮匹配匹配过的女生
bool vis_boy[MAXN];     // 记录每一轮匹配匹配过的男生
int match[MAXN];        // 记录每个男生匹配到的妹子 如果没有则为-1
int slack[MAXN];        // 记录每个汉子如果能被妹子倾心最少还需要多少期望值
int N;
 
bool dfs(int girl)
{
    vis_girl[girl] = true;
    for (int boy = 0; boy < N; ++boy) {
        if (vis_boy[boy]) continue; // 每一轮匹配 每个男生只尝试一次
        int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];
        if (gap == 0) {  // 如果符合要求
            vis_boy[boy] = true;
            if (match[boy] == -1 || dfs( match[boy] )) {    // 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人
                match[boy] = girl;
                return true;
            }
        } else {
            slack[boy] = min(slack[boy], gap);  // slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值 备胎的样子【捂脸
        }
    }
    return false;
}
 
int KM()
{
    memset(match, -1, sizeof match);    // 初始每个男生都没有匹配的女生
    memset(ex_boy, 0, sizeof ex_boy);   // 初始每个男生的期望值为0
    // 每个女生的初始期望值是与她相连的男生最大的好感度
    for (int i = 0; i < N; ++i) {
        ex_girl[i] = love[i][0];
        for (int j = 1; j < N; ++j) {
            ex_girl[i] = max(ex_girl[i], love[i][j]);
        }
    }
    // 尝试为每一个女生解决归宿问题
    for (int i = 0; i < N; ++i) {
        fill(slack, slack + N, INF);    // 因为要取最小值 初始化为无穷大
        while (1) {
            // 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止
            // 记录每轮匹配中男生女生是否被尝试匹配过
            memset(vis_girl, false, sizeof vis_girl);
            memset(vis_boy, false, sizeof vis_boy);
            if (dfs(i)) break;  // 找到归宿 退出
            // 如果不能找到 就降低期望值
            // 最小可降低的期望值
            int d = INF;
            for (int j = 0; j < N; ++j)
                if (!vis_boy[j]) d = min(d, slack[j]);
            for (int j = 0; j < N; ++j) {
                // 所有访问过的女生降低期望值
                if (vis_girl[j]) ex_girl[j] -= d;
                // 所有访问过的男生增加期望值
                if (vis_boy[j]) ex_boy[j] += d;
                // 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！
                else slack[j] -= d;
            }
        }
    }
    // 匹配完成 求出所有配对的好感度的和
    int res = 0;
    for (int i = 0; i < N; ++i)
        res += love[ match[i] ][i];
    return res;
}
 
int main()
{
    while (~scanf("%d", &N)) {
        for (int i = 0; i < N; ++i)
            for (int j = 0; j < N; ++j)
                scanf("%d", &love[i][j]);
        printf("%d\n", KM());
    }
    return 0;
} 
```

#### Tarjan算法

```
求强连通分量
int dfn[MAXN],low[MAXN],scc[MAXN],stk[MAXN];  //stk是栈的模拟
int index,sccnum,top;
void tarjan(int root){
	if(dfn[root]) return ;
	dfn[root]=low[root]=++index;
	stk[++top]=root;
	for(int i=head[root];i!=-1;i=e[i].next){
		int v=e[i].to;
		if(!dfn[v]){  //如果结点v未访问过
			tarjan(v);
			low[root]=min(low[root],low[v]);
		}
		else if(!scc[v]){  //如果还在栈内
			low[root]=min(low[root],dfn[v]);
		}
	}
	if(low[root]==dfn[root]){  //后代不能找到更浅的点
		sccnum++;
		while(true){
			int x=stk[top--];
			scc[x]=sccnum;
			if(x==root) break;
		}
	}
}
int dfn[MAXN],low[MAXN],scc[MAXN],stk[MAXN];  //stk是栈的模拟
int index,sccnum,top;
int num[MAXN];  //统计每个强连通分量有几个结点
void tarjan(int root){
	if(dfn[root]) return ;
	dfn[root]=low[root]=++index;
	stk[++top]=root;
	for(int i=head[root];i!=-1;i=e[i].next){
		int v=e[i].to;
		if(!dfn[v]){  //如果结点v未访问过
			tarjan(v);
			low[root]=min(low[root],low[v]);
		}
		else if(!scc[v]){  //如果还在栈内
			low[root]=min(low[root],dfn[v]);
		}
	}
	if(low[root]==dfn[root]){  //后代不能找到更浅的点
		sccnum++;
		while(true){
			int x=stk[top--];
			scc[x]=sccnum;
			num[sccnum]++;
			if(x==root) break;
		}
	}
}
```

#### LCA(最近公共祖先)

```
//倍增
std::vector<int>e[N];
int dep[N],fa[N][20];//dep 记录节点深度，fa 为倍增数组

void dfs(int u,int father){
    dep[u]=dep[father]+1;
    fa[u][0]=father;
    for(int i=1;i<=19;i++){// 使用倍增法填充 fa 数组 自底向上 
        fa[u][i]=fa[fa[u][i-1]][i-1];
    }
    for(int v : e[u]){
        if(v!=father){
            dfs(v,u);
        }
    }
}

int lca(int u,int v){
    if(dep[u]<dep[v]){
        std::swap(u,v);
    }
    for(int i=19;i>=0;i--){//自底向上 u，v跳到同一层
        if(dep[fa[u][i]]>=dep[v]){
            u=fa[u][i];
        }
    }
    if(u==v){
        return v;
    }
    for(int i=19;i>=0;i--){//自底向上 uv一起跳
        if(fa[u][i]!=fa[v][i]){
            u=fa[u][i];
            v=fa[v][i];
        }
    }
    return fa[u][0];
}
//tarian
```

### 前缀和

#### 一维：

$$
sum[i]=sum[i-1]+a[i];
区间和 ans=sum[r]-sum[l-1];
$$

#### 二维：

##### sum[i] [j]：从(0,0)到(i,j)范围的累加和 

$$
sum[i][j]+=sum[i][j-1]+sum[i-1][j]-sum[i-1]
$$

[j-1];

##### 查询左上角(a,b)到右下角(c,d)范围的累加和  

$$
ans=sum[c] [d]-sum[c] [b-1]-sum[a-1] [d]+sum[a-1] [b-1]
$$

#### 高维前缀和：

```
for(int j=0;j<n;j++){
	for(int i=0;i<1<<n;i++){
		if(i>>j&1)
			f[i]+=f[i^(1<<j)];
	}
}
```

### 差分：区间操作转换成两点操作

#### 一维：

$$
c[1]=a[1],c[i]=a[i]-a[i-1] (2<=i<=n)
$$

#### 二维: 

```
int c[1050][1050];//差分数组
int x,y,a,b;//(x,y)左上角 (a,b)右下角

void get_c(int c[1050][1050]){
	cin>>x>>y>>a>>b;
	for(int i=x;i<=a;i++){//逐行差分
		c[i][y]++;
		c[i][b]--;
	}
	for(int i=1;i<=n;i++){//逐行还原
		for(int j=1;j<=n;j++){
			c[i][j]+=c[i][j-1];
		}
	}
}
```

#### 等差数列：数组arr在 L---->R 操作(增加某个等差数列) 每次操作调用set，所有操作执行完后进行两边前缀和(即build() s首项,e末项,d公差)

```
void set(int l,int r,int s,int e,int d){
	arr[l]+=s;
	arr[l+1]+=d-s;
	arr[r+1]-=d+e;
	arr[r+2]+=e;
}
void build(){
	for(int i=1;i<=n;i++)arr[i]+=arr[i-1];
	for(int i=1;i<=n;i++)arr[i]+=arr[i-1];
}
```

#### 树上差分

##### ![image-20240923205227695](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240923205227695.png)

### 二分 具有单调性

#### 二分查找

```
//lower_bound()/upper_bound(); lower_bound寻找>=x的第一个元素位置，upper_bound寻找>x的第一个元素位置
//整数二分
int a[N];//下标从1开始
int find(int u){
	int l=0,r=n+1;//开区间
	while(l+1<r){//l+1==r 结束
		int mid=l+r>>1;
		if(a[mid]<=u) l=mid;//查找最后一个<=u 的数的下标
		else r=mid;
	}
	return l;//l指针指向是答案
}
int find(int u){
	int l=0,r=n+1;//开区间
	while(l+1<r){//l+1==r 结束
		int mid=l+r>>1;
		if(a[mid]>=u) r=mid;//查找第一个>=u 的数的下标
		else l=mid;
	}
	return r;//r指针指向是答案
}
//浮点二分
double find(double y){
	double l=-100,r=100;
	while(r-l>1e-5){
		double mid=(l+r)/2;
		if(mid*mid*mid<=y)l=mid;//求y(-10000<=y<=10000)的三次方根
		else r=mid;
	}
	return l;
}
```

#### 二分答案

```
//最大化
bool check(int x){
	... //计算y
	return y<=c;//x小 y小
	return y>=c;//x小 y大
}
int find(){
	int l=下限-1,r=上线+1；
	while(l+1<r){
		int mid=(l+r)>>1;
		if(check(mid)) l=mid;
		else r=mid;
	}
	return l;
}
//最小化
bool check(int x){
	... //计算y
	return y>=c;//x大 y大
	return y<=c;//x大 y小
}
int find(){
	int l=下限-1,r=上线+1；
	while(l+1<r){
		int mid=(l+r)>>1;
		if(check(mid)) r=mid;
		else l=mid;
	}
	return r;
}
```

### 三分：单峰函数极值

```
while(r-l>eps){
	double k=(r-l)/3;
	double lmid=l+k,rmid=r-k;
	if(f(lmid)<f(rmid)){
		l=lmid;
	}
	else{
		r=rmid;
	}
}
	std::cout<<l<<'\n';
```



## 排序()

#### 1.归并排序O(n)有稳定性 逆序对

```
void merge(int l, int m, int r) {//双指针
	int i = l;
	int a = l;
	int b = m + 1;
	while (a <= m && b <= r) {
	//归并
		help[i++] = arr[a] <= arr[b] ? arr[a++] : arr[b++];
	//逆序对   
	if(arr[a]<=arr[b]){
            help[i++]=arr[a++];
        }
    else{
            help[i++]=arr[b++];
            res+=m-a+1;
        }
	}// 左侧指针、右侧指针，必有一个越界、另一个不越界
	while (a <= m) {
		help[i++] = arr[a++];
	}
	while (b <= r) {
		help[i++] = arr[b++];
	}
	for (i = l; i <= r; i++) {
		arr[i] = help[i];
	}
}
//递归版本 O(n*logn n)
void mergesort1(int l, int r) {
	if (l == r)
		return;
	int m = (l + r) / 2;
	mergesort1(l, m);
	mergesort1(m + 1, r);
	merge(l, m, r);
}
//非递归版本 O(n*logn n)
void mergesort2(int l, int r) {
	// 一共发生O(logn)次
	for (int l, m, r, step = 1; step < n; step <<= 1) {
		// 内部分组merge，时间复杂度O(n)
		l = 0;
		while (l < n) {
			m = l + step - 1;
			if (m + 1 >= n) {
				//没有右侧
				break;
			}
			//有右侧，求右侧的右边界
			r = min(l + (step << 1) - 1, n - 1);
			merge(l, m, r);
			l = r + 1;
		}
	}
}
```

##### 2.(随机)快速排序

##### 3.基数排序：样本是10进制的非负整数

##### 4.计数排序：样本是整数 范围比较窄

##### 5.桶排序

##### 6.希尔排序

##### 7.堆排序

###### (以下为简单排序)

##### 8.插入排序

##### 9.冒泡排序

##### 10.选择排序



## DP

### 线性DP(递归):

#### 子数组最大累加和：

```
void  maxs(int nums[],int n){
	std::vector<int>dp(n);//子数组以i位置的数结尾
	dp[0]=nums[0];
	int ans=dp[0];
	for(int i=1;i<n;i++){
		dp[i]=max(nums[i],dp[i-1]+nums[i]);
		ans=max(ans,dp[i]);
	}
	std::cout<<ans<<'\n';
}
int left right;//left right分别是子数组最大累计和的左端点 右端点
void getidx(int nums[]){
	int sum=INT_MIN;
	for(int l=0,r=0,pre=INT_MAX;r<n;r++){
		if(pre>=0){
			pre+=nums[r];
		}
		else{//换开头
			pre=nums[r];
			l=r;
		}
		if(pre>sum){
			sum=pre;
			left=l;
			right=r;
		}
	}
}
```

#### 最长公共子序列/子串(LCS)：

##### 子序列字符相等，可以不连续；子串字符相等且连续

```
//最长公共子序列
int dp[N][N],pre[N][N];
string a,b;
//长度
void lcs(){
	int m=a.size(),n=b.size();
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			if(a[i-1]==b[j-1]){//下标从0开始匹配
				dp[i][j]=dp[i-1][j-1]+1;pre[i][j]=1;
			}
			else if(dp[i][j-1]>dp[i-1][j]){
				dp[i][j]=dp[i][j-1];pre[i][j]=2;
			}
			else {
				dp[i][j]=dp[i-1][j];pre[i][j]=3;
			}
		}
	}
	cout<<dp[m][n]<<'\n';
}
//输出
void getlcs(){
	int i=m,j=n,k=dp[m][n];
	string s;
	while(i>0&&j>0){
		if(pre[i][j]==1){
			s[k--]=a[i-1];
			i--,j--;
		}
		else if(pre[i][j]==2)
			j--;
		else 
			i--;
	}
	for(int i=1;i<=dp[m][n])
		cout<<s[i]<<" ";
}

```

#### 最长递增子序列(LIS)：只能求长度

```
int a[MAXN],dp[MAXN],n,ans=1;

void lis(){
	for(int i = 0; i<n; i++){
        dp[i] = 1;
        for(int j = 0; j < i; j++){
            if(a[j] < a[i])
                dp[i] = max(dp[i], dp[j] + 1);
        }
        ans = max(dp[i], ans);
    }
}
//二分优化
int a[N],b[N],len;
int find(int x){
	int l=0,r=len;
	while(l<=r){
		int mid=l+r>>1;
		if(x>dp[mid])
			l=mid+1;
		else 
			r=mid-1;
	}
	return l;
}

 void lis(){
 	len=1,dp[1]=a[1];
 	for(int i=2,j;i<=n;i++){
 		if(a[i]>dp[len])
 			dp[++len]=a[i];
 		else {
 			j=find(a[i]);
 			dp[j]=a[i];
 		}
 	}
 }
```

### 背包DP：

#### n件价值vi重量wi的物品，放进一个容量为m的背包,备注背包只能选择一次 下标从1开始

#### 01背包：dp[i]表示不同重量下的最大价值

```
//dp[i][j]表示前i件物品放入容量为j的背包的最大价值
for(int i=1;i<=n;i++){//枚举数量
	for(int j=1;j<=m;j++){//枚举体积
		if(j<w[i])
			dp[i][j]=dp[i-1][j];
		else 
			dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);
	}
}
cout<<dp[n][m]<<'\n';
//一维压缩
for(int i=1;i<=n;i++){
	for(int j=m;j>=w[i];j--){
		dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
	}
}
cout<<dp[m]<<'\n';
/二维01背包
void solve(){
	cin>>n>>V>>M;//数量 背包容量 背包承重
    fof(int i=1;i<=n;i++){
    	cin>>v>>m>>w;//体积 重量 价值
    	for(int j=V;j>=v;j--){
    		for(int k=M;k>=m;k--){
    			dp[j][k]=max(dp[j][k],dp[j-v][k-m]+w);
    		}
    	}
    }
}
//变种bool版
	dp[0][0]=true;
    for(int i=1;i<=n;i++){
        for(int j=i;j>=1;j--){
            for(int k=ans;k>=a[i];k--){//ans是a[i]的和
                dp[j][k]|=dp[j-1][k-a[i]];//选出j个，且和为k
            }
        }
    }
```

#### 有依赖的背包：dp[i]表示不同价值下的最小重量

```
void solve(){
	memset(dp,INF,sizeof(dp));
	dp[0]=0;
	for(int i=0;i<n;i++){
		for(int j=m;j>=v[i];j--){
			dp[j]=std::min(dp[j],dp[j-v[i]]+w[i]);
		}
	}
	int ans;
	for(int i=0;i<m;i++) if(dp[i]<=t) ans=i;
	std::cout<<ans<<'\n';
	}
```

#### 分组背包：n件价值w[i]重量v[i]的物品，放进一个容量为m的背包,同一组有s[i]件但只能选其中一件，求最大价值

```
//朴素
for(int i=1;i<=n;i++){//数量
	for(int j=1;j<=m;j++){//容量
		for(int k=0;k<=s[i];k++)//选与不选
			if(j>=v[i][k])
				dp[i][j]=max(dp[i][j],dp[i-1][j-v[i]]+w[i][k]);
	}
}
cout<<dp[n][m];
//一维压缩
for(int i=1;i<=n;i++){
	cin>>s;
	for(int j=1;j<=s;j++){
		cin>>v[j]>>w[j];// 体积 价值
	}
	for(int j=m;j>=1;j--){
		for(int k=0;k<=s;k++){
			if(j>=v[k])
				dp[j]=max(dp[j],dp[j-v[k]]+w[k]);
		}
	}
}
cout<<dp[m];
```

#### 完全背包：每种物品可以选择无数次，求最大价值

```
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++)
		if(j<w[i])
			dp[i][j]=dp[i-1][j];
		else {
			dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i]);//与01背包不同点第i件物品还可以放入 即dp[i][j-w[i]]+v[i]
		}
}
//一维压缩
for(int i=1;i<=n;i++){
		for(int j=w[i];j<=m;j++){
			dp[j]=max(dp[j-w[i]]+v[i],dp[j]);
		}
	}
	cout<<dp[m]<<"\n";
```

#### 多重背包：

```
//与01背包 第i件物品有s[i]件 重量k*w[i] 价值k*v[i] 
/二进制拆分成01背包
const int N=1e5+7;
int n,m;
int v,w,s;
int vv[N],ww[N],dp[N];

void solve() {
    std::cin>>n>>m;
    int cnt=0;//拆分计数
    for(int i=1;i<=n;i++){
        std::cin>>v>>w>>s;// 价值 重量 数量
        for(int j=1;j<=s;j<<=1){
            vv[++cnt]=j*v;//价值
            ww[cnt]=j*w;//重量
            s-=j;
        }
        if(s){//还有剩余
            vv[++cnt]=s*v;
            ww[cnt]=s*w;
        }
    }
    for(int i=1;i<=cnt;i++){
        for(int j=m;j>=ww[i];j--){
            dp[j]=std::max(dp[j],dp[j-ww[i]]+vv[i]);
        }
    }
    std::cout<<dp[m];
}
//单调队列优化
for(int i=1;i<=m;i++){
			cin>>w>>v>>num;
			for(int d=0;d<w;d++){	//模拟余数
				head=tail=1;	//初值
				for(int j=0;j<=(n-d)/w;j++){
				//（n-d）/w指当前余数有多少个
					int o=f[j*w+d]-v*j;//要进队列的值
                    while(q[tail-1]<=o&&head<tail)tail--;//弹出队尾
                    q[tail]=o;//进队
					p[tail++]=j;//下标
                    while(j-p[head]>num&&head<tail)head++;//弹出队头
                    f[j*w+d]=max(f[j*w+d],q[head]+v*j);//找最大值
				}
			}
		}
cout<<f[w];
```

#### 混合背包：

```
void solve(){
	int cnt=0;
	for(int i=1;i<=n;i++){
		cin>>w>>v>>s;
	}
	if(s==0){//完全背包
		vv[++cnt]=v;
		ww[cntt]=w;
		c[cnt]=0;//背包类型 完全背包
	}
	else{
		if(s==-1){
			s=1;//01背包转成多重背包
		}
		int k=1;
		while(s>=k){
			vv[++cnt]=k*v;
			ww[cnt]=k*w;
			c[cnt]=1;
			s-=k;
			k<<=1;
		}
		if(s){
			vv[++cnt]=s*v;
			ww[cnt]=s*w;
			c[cnt]=1;//背包类型 01背包
		}
	}
	for(int i=1;i<=cnt;i++){
		if(c[i]==1){//01背包
			for(int j=m;j>=w[i];j--){
				dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
			}
		}
		else{//完全背包
			for(int j=w[i];j<=m;j++){
				dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
			}
		}
	}
	cout<<dp[m]<<'\n';
}
```

#### 超大背包：

```
void solve(){
	//将 n 二分，前半部分的所有可能取值全部存入 pair 中（数位01设置选择） 
    int n1 = n / 2;
    int num1 = 1 << n1;
    for(int i = 0; i < num1; i++) {
        long long sw = 0, sv = 0;
        for(int j = 0; j < n1; j++) {
            if((i >> j) & 1) {
                sw += w[j];
                sv += v[j];
            }
        }
        pi[i] = make_pair(sw, sv);
    }
    
    //单调排序，筛除 w[i]>=w[j]但v[i]<=v[j]的 pair 
    sort(pi, pi + num1);
    int m = 1;
    for(int i = 1; i < num1; i++) {
        if(pi[m-1].second < pi[i].second) {
            pi[m++] = pi[i];
        }
    }
    
    //处理另一半 n ，寻找满足 w 时 最大的 v 
    int n2 = n - n1;
    int num2 = 1 << n2;
    long long ans = 0;
    for(int i = 0; i < num2; i++) {
        long long sw = 0, sv = 0;
        for(int j = 0; j < n2; j++) {
            if((i >> j) & 1) {
                sw += w[n1 + j];
                sv += v[n1 + j];
            }
        }
        if(sw <= W) {
            long long tv = (lower_bound(pi, pi + m, make_pair(W - sw, INF)) - 1)->second;
            ans = max(ans, sv + tv);
        }
    }
    cout<<ans<<endl;
}
```

### 区间DP：

```
const int N=1005;
int n;
int a[N],sum[N],dp[N][N];//dp[i][j]从i到j合并的代价

void solve() {
    memset(dp,0x3f3f,sizeof dp);
    std::cin>>n;
    for(int i=1;i<=n;i++){
        std::cin>>a[i];
        sum[i]=sum[i-1]+a[i];
        dp[i][i]=0;
    }
    for(int len=2;len<=n;len++){	//区间长度
        for(int l=1;l+len-1<=n;l++){//区间端点
            int r=l+len-1;		
            for(int k=l;k<r;k++){	//区间分割点
                dp[l][r]=std::min(dp[l][r],dp[l][k]+dp[k+1][r]+sum[r]-sum[l-1]);
            }
        }
    }
    std::cout<<dp[1][n];
}
环形的就将数组复制一次 len*2(破环为链)
```

### 树型DP：

#### 套路：

##### 1.分析父树得到的答案需要从子树的哪些信息

##### 2.把子树信息的全集定义成递归返回值

##### 3.通过递归让子树返回全集信息

##### 4.整合子树的全集信息得到父树的全集信息并返回

```
vector<int>G[N];
int a[N],dp[N],ans;
void dfs(int u,int fat)
{
    dp[u]=a[u];
    for(auto v:G[u])
    {
        if(v!=fat)
        {
            dfs(v,u);
            dp[u]+=max(0,dp[v]);
        }
    }
    ans=max(ans,dp[u]);
}
//换根
const int N=5e5+5;
vector<pair<int,int> >G[N];
int dp[N][3],pot[N];
void dfs(int u,int fat)
{
    for(auto it:G[u])
    {
        int v=it.F,cost=it.S;
        if(v==fat)
            continue;
        dfs(v,u);
        if(dp[u][0]<=dp[v][0]+cost)
        {
            dp[u][1]=dp[u][0];
            dp[u][0]=dp[v][0]+cost;
            pot[u]=v;
        }
        else if(dp[u][1]<dp[v][0]+cost)
            dp[u][1]=dp[v][0]+cost;
    }
}
void dfs1(int u,int fat)
{
    for(auto it:G[u])
    {
        int v=it.F,cost=it.S;
        if(v==fat)
            continue;
        if(pot[u]==v)
            dp[v][2]=cost+max(dp[u][1],dp[u][2]);
        else
            dp[v][2]=cost+max(dp[u][0],dp[u][2]);
        dfs1(v,u);
    }
}

```

### 状压DP：

```
用二进制表示状态，用十进制存储状态
用位运算筛选合法状态并判断状态转移条件
计算时累加上次兼容状态

for(int i=1;i<(1<<n);i++)
    {
        dp[i]=get(i);
        for(int j=i;j;j=(j-1)&i)
            dp[i]=min(dp[i],dp[j]+dp[j^i]);
    }
    cout<<dp[ (1<<n)-1 ]<<endl;

```

### 高维前缀和：

```
	for(int i=0;i<22;i++)
        for(int j=0;j<(1<<22);j++)
            if(j&(1<<i))
                dp[j]+=dp[j^(1<<i)];

```

### 数位DP:

#### 区间转化(前缀和思想)

##### 欲求[a,b]中的...的个数，先求[0,x]的...的个数dp[x] ans=dp[b]-dp[a-1]

#### 分类填数

##### 设整数x一共n位，x表示为a_n a_n-1... a1，从高位到低位枚举填数，不含前导0，最高位1~a_n 其他位0~ai 

```
const int N=12;
int a[N];
int f[N][10];//i位数且最高位是j的windy数的个数

void init(){
    for(int i=0;i<=9;i++)f[1][i]=1;//1位数
    for(int i=2;i<N;i++){//枚举位数
        for(int j=0;j<=9;j++){//枚举第i位
            for(int k=0;k<=9;k++){//枚举第i-1位
                if(abs(k-j)>=2)
                    f[i][j]+=f[i-1][k];
            }
        }
    }
}

int dp(int x){
    if(!x)return 0;
    int cnt=0;
    while(x) a[++cnt]=x%10,x/=10;//将x取出给a[n]
    int res=0,last=-2;
    //答案有cnt位
    for(int i=cnt;i>=1;i--){
        int now=a[i];
        for(int j=(i==cnt);j<now;j++){//i==cnt 即最高位1~ai 否则0~ai
            if(abs(j-last)>=2)res+=f[i][j];
        }
        if(abs(now-last)<2)break;
        last=now;
        if(i==1)res++;//走到个位数
    }
    //答案小于cnt位
    for(int i=1;i<cnt;i++){
        for(int j=1;j<=9;j++){
            res+=f[i][j];
        }
    }
    return res;
}
```



## 数论

### 高精度：

```
//加法 
const int N=505;
int a[N],b[N],c[N];
int la,lb,lc;

void add(int a[],int b[],int c[]){ //a+b=c
  for(int i=1; i<=lc; i++){
    c[i]+=a[i]+b[i]; //求和
    c[i+1]+=c[i]/10; //进位
    c[i]%=10;        //存余
  }
  if(c[lc+1]) lc++;  //最高位
}
int main(){
  string sa,sb; cin>>sa>>sb;
  la=sa.size(),lb=sb.size(),lc=max(la,lb);
  for(int i=1; i<=la; i++) a[i]=sa[la-i]-'0';
  for(int i=1; i<=lb; i++) b[i]=sb[lb-i]-'0';
  add(a,b,c);
  for(int i=lc; i; i--) printf("%d",c[i]);
  return 0;
}
//减法 
const int N=20000;
int a[N],b[N],c[N];
int la,lb,lc;

bool cmp(int a[],int b[]){
  if(la!=lb) return la<lb;
  for(int i=la; i; i--)
    if(a[i]!=b[i]) return a[i]<b[i];
  return false;  //相等时,避免-0
}
void sub(int a[],int b[],int c[]){ //a-b=c
  for(int i=1; i<=lc; i++){
    if(a[i]<b[i]) a[i+1]--,a[i]+=10;
    c[i]=a[i]-b[i];
  }
  while(c[lc]==0&&lc>1) lc--; //去0
}
int main(){
  string sa,sb; cin>>sa>>sb;
  la=sa.size(),lb=sb.size(),lc=max(la,lb);
  for(int i=1;i<=la;i++) a[i]=sa[la-i]-'0';
  for(int i=1;i<=lb;i++) b[i]=sb[lb-i]-'0';
  if(cmp(a,b)) swap(a,b),cout<<'-';
  sub(a,b,c);
  for(int i=lc;i;i--) printf("%d",c[i]);
  return 0;
}


//乘法
const int N=1e6+7;
int a[N],b[N],c[N];
int la,lb,lc;

void mul(int a[],int b[],int c[]){
    for(int i=1;i<=la;i++){
        for(int j=1;j<=lb;j++){
            c[i+j-1]+=a[i]*b[j];
        }
    }
    for(int i=1;i<lc;i++){
        c[i+1]+=c[i]/10;
        c[i]%=10;
    }
    while(!c[lc]&&lc>1)lc--;
}
void solve() {
    std::string sa,sb;
    std::cin>>sa>>sb;
    la=sa.size(),lb=sb.size(),lc=la+lb;
    for(int i=1;i<=la;i++) a[i]=sa[la-i]-'0';
    for(int i=1;i<=lb;i++) b[i]=sb[lb-i]-'0';
    mul(a,b,c);
    for(int i=lc;i;i--)std::cout<<c[i];
}
//除法
const int N=5005;
int a[N],b,c[N];
int len;

void div(int a[],int b,int c[]){ //a/b=c
  long long t=0;
  for(int i=len;i>=1;i--){
    t=t*10+a[i];  //被除数
    c[i]=t/b;     //存商
    t%=b;         //余数
  }
  while(c[len]==0&&len>1) len--; //去0  
}
int main(){        
  char A[N]; cin>>A>>b; len=strlen(A);
  for(int i=1;i<=len;i++) a[i]=A[len-i]-'0';
  div(a,b,c);
  for(int i=len;i;i--) cout<<c[i];  
  return 0;
}
```

### 分数规划

##### 给定一系列整数a1,a2,……,an以及b1,b2,……,bn

##### 求解一组xi(1 <= i <= n,xi = 0或1)使得下式最大化

##### 解法：在值域[L,R]内二分mid，判断是否存在一组解xi使得 若是则说明二分值 mid 比能求得的最大值小，令L = mid;否则说明二分值 mid 大于能求得的最大值，令R = mid；直到二分值达到精度要求。

```
int a[maxn],b[maxn];
double tt[maxn];
d ans;
int check(double x){
	double sum=0;
	for(int i=1;i<=n;++i)
	tt[i]=a[i]-x*b[i];//每组ai-mid*bi
	sort(tt+1,tt+1+n);
	for(int i=n;i>=k+1;--i) sum+=tt[i];//检查前n-k组的和
	return sum>=0;
}

double L=0,R=1,mid;
		while(R-L>1e-4)//注意精度要求
		{
			mid=(L+R)/2;
			if(check(mid))L=mid;
			else R=mid;
		}
```

#### 反素数：

```
int p[16]={2,3,5,7,11,13,17,19,23,29,31,37,41,47,53};
ll ans,n;
void dfs(ll x,ll tmp,ll num){
	if(num>n)return ;
	if(num==n&&ans>tmp)ans=tmp;
	for(int i=1;i<=63;i++){
		if(ans/p[x]<tmp)break;
		dfs(x+1,tmp*=p[x],num*(i+1));
	}
}
void solve(){
	while(cin>>n){
		ans=~011;
		dfs(0,1,1);
		cout<<ans<<'\n';
	}
}
```

#### 质数判断：

```
bool isPrime(long n){
	if(n<=1)return 0;
	for(int i=2;i*i<=n;i++){
		if(n%i==0)return 0;
	}
	return 1;
}
```

### 质因数分解：

```
void f(int n){
    for (int i = 2; i * i <= n;i++){
        if(n%i==0){
            std::cout << i << "'\n";
            while(n%i==0)
                n /= i;
        }
        if(n>1)
            std::cout << n << "\n";
    }
}
```

### 质数筛：

#### 1.埃氏筛(n*log(log n))

```
int ehrlich(int n) {
    // visit[i] = true，代表i是合数
    // visit[i] = false，代表i是质数
    // 初始时认为0~n所有数都是质数
    std::vector<bool> visit(n + 1, 0);
    for (int i = 2; i * i <= n; i++) {
        if (!visit[i]) {
            for (int j = i * i; j <= n; j += i) {
                visit[j] = true;
            }
        }
    }
    int cnt = 0;
    for (int i = 2; i <= n; i++) {
        if (!visit[i]) {
            // 此时i就是质数，可以收集，也可以计数
            cnt++;
        }
    }
    return cnt;
    }
```

#### 2.欧拉筛O(n)------只被自己的最小质因数筛

```
 int euler(int n) {
	// visit[i] = true，代表i是合数
	// visit[i] = false，代表i是质数
	// 初始时认为0~n所有数都是质数
	 std::vector<bool>visit(n + 1, 0);
	// prime收集所有的质数，收集的个数是cnt
	 std::vector<int>prime(n / 2 + 1, 0);
	int cnt = 0;
	for (int i = 2; i <= n; i++) {
		if (!visit[i]) {
			prime[cnt++] = i;
		}
		for (int j = 0; j < cnt; j++) {
			if (i * prime[j] > n) {
				break;
			}
			visit[i * prime[j]] = 1;
			if (i % prime[j] == 0) {
				break;
			}
		}
	}
	return cnt;
}
```

### 快速幂:

#### 乘法快速幂:

```
int quickpower(int a, int b) {
	// a^b % p
	long ans = 1, base = a;
	while (b > 0) {
		if (b & 1) {
			ans = (ans * base) % p;
		}
		base = (base * base) % p;
		b >>= 1;
	}
	return ans;
}
```

#### 矩阵快速幂:

```
//矩阵快速幂---O(log n* k^3)
#define mod 1000000007
#define ll long long
using namespace std;
ll n, p;

struct Mat {
	ll m[101][101];
};//结构体存矩阵 
Mat a, e;//a是输入的矩阵，e是单位矩阵 
Mat Mul(Mat x, Mat y) { //矩阵乘 
	Mat c;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			c.m[i][j] = 0;//初始化
	for (int i = 1; i <= n; i++)//k^3
		for (int j = 1; j <= n; j++)
			for (int k = 1; k <= n; k++) {
				c.m[i][j] = c.m[i][j] % mod + x.m[i][k] * y.m[k][j] % mod;
			}
	return c;
}
Mat pow(Mat x, ll y) { //矩阵快速幂 
	Mat ans = e;
	while (y) {
		if (y & 1) {
			ans = Mul(ans, x);
		}
		x = Mul(x, x);
		y >>= 1;
	}
	return ans;
}
void solve() {
	cin >> n >> p;//求 n^p
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a.m[i][j];
		}
	}
	//单位矩阵 
	for (int i = 1; i <= n; i++) {
		e.m[i][i] = 1;
	}
	Mat ans = pow(a, p);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cout << ans.m[i][j] % mod << " ";
		}
		cout << endl;
	}
}

signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int t = 1;
	while (t--) {
		solve();
	}
	return 0;
}
```

### 逆元(倒数 O(n))：

<img src="C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240708142653411.png" alt="image-20240708142653411" style="zoom:200%;" />

```
//逆元
const int N = 3000001;
int inv[N];
int n, p;
void build(int n) {
	inv[1] = 1;
	for (int i = 2; i <= n; i++) {
		inv[i] = (int)(p - (long)inv[p % i] * (p / i) % p);
	}
}
void solve() {
	cin >> n >> p;
	build(n);
	for (int i = 1; i <= n; i++)cout << inv[i] << '\n';
}
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int t = 1;
	while (t--) {
		solve();
	}
}
```

![image-20240708143326773](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240708143326773.png)

```
int quickpower(int a,int b){
	ll ans=1,base=a;
	while(b>0){
		if(b&1)ans=(ans*base)%mod;
		base=(base*base)%mod;
		b>>=1;
	}
	return ans;
}
void init(){
	fac[1]=1;
	for(int i=2;i<=N;i++)fac[i]=((ll)i*fac[i-1])%mod;
	inv[0]=1;
	for(int i=1;i<=N;i++)inv[i]=quickpower(fac[i],mod-2);
	inv[n]=quickpower(fac[i],mod-2);
	for(int i=N-1;i>=0;i--)inv[i]((ll)(i+1)*inv[i+1])%mod;
}
void solve(){
	cin>>T>>N;
	ll ans=0;
	init();
	for(int i=0;i<T;i++){
		cin>>n>>m;
		ans=ans^fac[n]*inv[m]%mod*inv[n-m]%mod;
	}
	cout<<ans<<'\n';
}
```

### 组合数：

#### C(n,m)=C(n,n-m)=C(n-1,m-1)+C(n-1,m)

#### 暴力：

```
long long c[MAXN][MAXN];
void get(){
	c[0][0]=1;
	for(int i=1;i<=n;i++){
		c[i][0]=1,c[i][1]=i;
		for(int j=1;j<=m;j++){
			c[i][j]=c[i-1][j-1]+c[i-1][j];
			c[i][j]%mod;
		}
	}
}
```

### 卢卡斯定理：

```
//快速幂
ll quickpower(ll a,ll b,ll p){
	ll ans=1,base=a;
	while(b>0){
		if(b&1)ans=(ans*base)%p;
		base=(base*base)%p;
		b>>=1;
	}
	return ans;
}
//组合数
ll C(ll n,ll m){
	if(m>n)return 0;
	return ((a[n]*quickpower(a[m],p-2,p))%p*quickpower(a[n-m],p-2,p)%p);
}
//卢卡斯
ll Lucas(ll n,ll m){
	if(!m)return 1;
	return C(n%p,m%p)*Lucas(n/p,m/p)%p;
}
```

#### 放球模型：

##### 1.n个球相同，m个盒子不同，盒子不可空 方案数：C(n-1,m-1)

##### 2.n个球相同，m个盒子不同，盒子可空 方案数：C(n+m-1,m-1)

##### 3.n个球相同，m个盒子相同，盒子不可空 方案数：ans = dp [n] [m]=dp [n-1] [m-1] + dp [n-m] [m]

##### 4.n个球相同，m个盒子相同，盒子可空 方案数：ans = dp [n] [1] +... + dp [n] [min(n,m)]

#### Miller-Rabin素性检验算法:O(k^log3 n)

##### powmod为乘法快速幂 quickpower

```
bool MillerRabin(ll n){
	if(n==2)return 1;
	if(n<=1||n%2==0)return 0;
	ll base[7]={2,325,9375,28178,450775,9780504,1795265022};
	ll u=n-1,k=0;
	while(u%2==0)u/=2,k++;
	for(auto x:base){
		if(x%n==0)continue;
        ll v=powermod(x,u,n);
        if(v==1||v==n-1)continue;
        for(int j=1;j<=k;j++){
        	ll last=v; 
			v=(__int128v*v%n);
			if(v==1){
			if(last!=n-1)return 0;
			break;
			}
		}
		if(v!=1)return 0;
	}
	return 1;
}
```

### 数论分块(求n/i的求和)：

![image-20240715163442254](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240715163442254.png)

### 01分数规划(n*log n *log m)

![image-20240828162614678](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240828162614678.png)

![image-20240828171702161](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240828171702161.png)

```
const int N = 1005;
const double eps = 1e-6;
int n, k; 
double c[N], a[N], b[N];
bool cmp(double x, double y)
{
	return x > y;
}
bool check(double mid)
{
	for (int i = 1; i <= n; i++)
		c[i] = a[i] - b[i] * mid; //公式
	sort(c + 1, c + n + 1, cmp);
	double sum = 0;
	for (int i = 1; i <= n - k; i++) //贪心取最大的
		sum += c[i];
	return sum >= 0;
}
signed main()
{
	while (cin >> n >> k && n)
	{
		for (int i = 1; i <= n; i++)cin >> a[i];
		for (int i = 1; i <= n; i++)cin >> b[i];
		double l = 0, r = 1;
		while (r - l > eps) //浮点数二分
		{
			double mid = (l + r) / 2.0;
			if (check(mid))
				l = mid;
			else
				r = mid;
		}
		cout << (int)(l * 100 + 0.5) << endl; // 四舍五入
	}
	return 0;
}
```

### Striling数：

#### 第一类：表示将n个不同元素构成m个圆排列的数目

#### 第二类:将 cnt 个小球放进k个无差别的盒子，盒子不可空(将n个不同元素分成m个集合的方案数),求放置的方法数

$$
s[i][j]=j*s[i-1][j]+s[i-1][j-1];
$$

```
void init(){
	s[0][0]=1;
	for(int i=1;i<=8;i++){//n<=1e7 cnt<=8
		for(int j=1;j<=8;j++)
		s[i][j]=j*s[i-1][j]+s[i-1][j-1];
	}
}
void solve(){
	int n,k;cin>>n>>k;
	f(n);
	if(k>cnt)cout<<0<<'\n';
	else cout<<s[cnt][k]<<'\n';
}
```

### 卡特兰数

- 出栈次序
- n对括号正确匹配数目 
- 给定节点组成二叉搜索树
- 在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线段不相交的方法数
- 求一个凸多边形区域划分成三角形区域的方法数（这里建议记住卡特兰数的前几项：1, 1, 2, 5, 14, 42, 132, 429, 1430...）

$$
&公式一：&
f[n]=f[0]*f[n-1]+f[1]*f[n-2]+...+f[n-1]*f[0](n>1)\\
&公式二：&f[n]=f[n-1]*(4*n-2)/(n+1)\\
&公式三：&f[n]=C_(2n)^m/(n+1)(n=0,1,2,3...)\\
&公式四：&f[n]=C_2n^n-C_(2n)^(n-1)(n=0,1,2...)
$$

```
//法1
  	f[0]=f[1]=1;
	for(int i=2;i<=n;i++){
		for(int j=0;j<i;j++){
			f[i]+=f[j]*f[i-j-1];
		}
	}
    std::cout<<f[n];
//法2
	f[0]=f[1]=1;
	for(int i=2;i<=n;i++){
		f[i]+=f[i-1]*(4*i-2)/(i+1);
	}
	std::cout<<f[n];
//法3
	for(int i=1;i<=2*n;i++){
    	c[i][0]=c[i][i]=1;
    	for(int j=1;j<i;j++){
    		c[i][j]=c[i-1][j]+c[i-1][j-1];
		}
	}
	std::cout<<c[2*n][n]/(n+1);
//法4
	for(int i=1;i<=2*n;i++){
    	c[i][0]=c[i][i]=1;
    	for(int j=1;j<i;j++){
    		c[i][j]=c[i-1][j]+c[i-1][j-1];
		}
	}
    std::cout<<c[2*n][n]-c[2*n][n-1];
```


### 扩欧exgcd:

```
//ax+by=gcd(a,b)
void exgcd(int a,int b,int &x,int &y){
	if(!b){
	x=1,y=0;return ;
	}
	int p;
	exgcd(b,a%b,x,y);
	p=x,x=y,y=p-(a/b)*y;
	return ;
}
```

### 中国剩余定理：

![image-20240715160359994](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240715160359994.png)

### 欧拉函数

### 同余原理：

#### 加法：(a+b+c+d)%mod=((a+b)%mod+(c+d)%mod)%mod

#### 减法：(a-b)%mod=(a%mod-b%mod+mod)%mod

#### 乘法：(a *b *c)%mod=a% mod *b%mod *c%mo



## 博弈类(公平组合游戏)：

##### 两个玩家轮流行动且游戏方式一致，游戏一定会在有限步数内分出胜负，以玩家无法行动结束

### 巴什博弈(Bash Game)：

##### 一共n颗石子，两人轮流拿，每次可以拿1~m颗石子，拿到最后一颗石子的人获胜

```
n % (m + 1) != 0 ? "先手赢" : "后手赢";
```

### 尼姆博弈(Nim Game)：

##### 有 n 堆石子，每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取， 拿到最后一颗石子的人获胜

```
a1^a2...^an!=0 //先手赢，反之后手赢
```

### 反nim游戏：

```
string Nim(){
	int eor=0,sum=0;
	for(int i=0;i<n;i++){
		eor^=a[i];
		sum+=a[i]==1?1:0;
	}
	if(sum==n)return (n&1)==1?"先手":"后手";
	else eor!=0?"先手":"后手";
}
```

### 斐波那契博弈(Fibonacci Game + Zekendorf定理)：

##### n颗石子,先手第一轮可以任意取石子，接下来的每一轮当前玩家最少取走一颗石子，最大取走上一次的两倍，取走数量不大于场上剩余，求先手第一轮取多少石子胜利

#### n为斐波那契数，则先手必败

### 威佐夫博弈(Wythoff Game)：

##### 两堆石子，任意数量，轮流取石子，每次有两种取法，最后取完石子的胜利

##### 1.在任意堆中取任意多石子

##### 2.在两堆中取相同石子

#### 小！=（大-小）*黄金分割比例，先手胜利

#### 小==（大-小）*黄金分割比例 后手胜利

#### 黄金分割比例

```
double split = (sqrt(5.0) + 1.0) / 2.0;
```

### SG博弈()：

#### SG函数：SG(i)==0,即先手必败的点为i 

##### mex过程：当前状态点为k，SG(K)=查看k所有后继节点的SG值，其中没有出现的最小自然数 SG(k)!=0,则k为必胜态，SG(k)==0，测k为必败态

```
int f[N],sg[N],vis[N];

void sg(int n,int m){
	memset(sg,0,sizeof(sg));
	for(int i=1;i<=n;i++){
		memset(vis,false,sizeof(vis));
		for(int j=0;j<m&&f[j]<=i;j++)
			vis[sg[i-f[j]]]=true;
		for(int j=0;j<=n;j++){
			if(!vis[j]){
				sg[i]=j;
				break;
			}
		}
	}
	if(!sg[n])std::cout<<"先手赢";
	else std::cout<<"后手赢";
}
```

#### SG定理：

```
SG(总)=SG(1)^SG(2)^SG(3)...^SG(n)
SG(总)！=0，先手胜利 否则 SG(总)==0，后手胜利
```

### trick

##### lambda表达式：

```
auto f=[](auto a,auto b){
	return a+b;
};

	auto f = [&](auto &&self, int n) -> int {
        if (n == 1) return 1;  
        if (n == 2) return 2; 
        return self(self, n - 1) + self(self, n - 2);
	};
		cout<<f(f,n);
		
    auto cmp = []( std::pair<int, int>& p1, std::pair<int, int>& p2) {
        return (p1.first+p1.second) < (p2.first+p2.second);
    };
    std::sort(a.begin(),a.end(),cmp);
```

##### 结构体内嵌比较函数bool operator ＜ (const node &x) const {}

```
//每次往结构体a[i]里赋值，struct都会自动进行比较 
//struct自动从小到大排序，让当前r小的return ，那么operator后面跟的符号就是 < 
struct node
 {
     int r;
     bool operator <(const node &a)const{//相当于嵌套cmp
         return r < a.r;
     }
 }a[10];
```

##### 格式化输入

```
int a,b,c;
scanf("%lld,%lld,...,%lld",&a,&b,&c);
```

##### 字符串处理

```
    std::string s;
    std::cin >> std::ws;  // 去除前导空格
    std::getline(std::cin, s);  // 读取整行，包括空格
```

##### 中位数定理

```
给定一个数组，每次操作加1或者减1，将所有元素变成相同的最小操作次数则是将所有元素变成中位数即可
int res = 1e18;//ml mr 分别表示左右两半的中位数
for (auto xl : {ml, ml - 1}) {
    for (auto xr : {mr, mr + 1}) {
        if (xl == xr) {
            continue;
        }
        int ans = 0;
        for (int i = 0; i < m; i++) {
            ans += abs(a[i] - xl);
            ans += abs(a[m + i] - xr);
        }
        res = std::min(ans, res);
    }
}

```

##### 记忆化搜索(自上而下dp)

```
int dp[5050];

int fib(int n){
    if(n==1)return 1;
    if(n==2)return 2;
    if(dp[n])return dp[n];
    dp[n]=fib(n-1)+fib(n-2);
    return dp[n];
}
```

##### 二进制枚举

```
    for(int i = 0; i < (1<<n); i++) {//从0～2^n-1个状态
    	for(int j=0;j<n;j++){
    		if(i>>j&1)std::cout<<j<<' ';
    	}
}
```

##### 末尾0去掉

```
//x=1324.120000
//法1 std::cout<<x<<'\n';
//法2 printf("%g\n",x);
```

##### 循环左移

```
//字符串从下标1开始输入
//string s;
//cin>>s;
//s='0'+s;

void solve(){
	std::string s;
	std::cin>>s;
	s+=s;//12345 -->1234512345
}
```

##### 遍历对角线

```
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            int sum=g[i][j];
            // 左上
            for (int k = 1; i - k >= 0 && j - k >= 0; k++) {
                    sum += g[i - k][j - k];
            }
            // 右上
            for (int k = 1; i - k >= 0 && j + k < m; k++) {
                    sum += g[i - k][j + k];
                }
            // 左下
            for (int k = 1; i + k < n && j - k >= 0; k++) {
                    sum += g[i + k][j - k];
            }
            // 右下
            for (int k = 1; i + k < n && j + k < m; k++) {
                sum += g[i + k][j + k];
            }
            mx=std::max(mx,sum);
      
```

##### 离散化 值域大，数量少

```
//sort+unique 区间查找、更新
std::vector<int>a(n),b(n);//b是a的离散下标数组
std::sort(b.begin(),b.end());
b.erase(std::unique(b.begin(),b.end()),b.end());
for(int i=0;i<n;i++){
      b[i]=std::lower_bound(b.begin(),b.end(),a[i])-b.begin();
}
//map
std::vector<int>a(n);
std::map<int,int>mp;//mp是a的离散下标数组
for(int i=0;i<n;i++){
    std::cin>>a[i];
    mp[a[i]]=0;
}
int idx=0;
for(auto &i:mp){
    i.second=idx++;
}
```

##### 随机数

```
//生成随机数x到y
std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());
i64 rnd(i64 x, i64 y) {
    return std::uniform_int_distribution<i64>(x, y)(rng);
}
```

##### 寻找数组没出现最大的数

```
int findmx(const std::vector<int>& a) {
    if (a.empty()) {
        return 1;  
    }
    std::unordered_set<int> s(a.begin(), a.end());
    int mx = *std::max_element(a.begin(), a.end());
    for (int i = mx; i > 0; --i) {
        if (s.find(i) == s.end()) {
            return i;  
        }
    }
    return mx + 1;//a={1,3,4,5} mx+1=2
}
```

##### 多项式

```
double f(double x)
{
    //多项式系数
    //    for(int i=0;i<=n;i++)
    //      std::cin>>a[i];
	double temp=1.0,ans=0.0;
	for(int i=n;i>=0;i--,temp*=x) 
        ans+=a[i]*temp;
	return ans;
}

//秦九韶算法从里到外逐层计算一次多项式的值
double F(double x)
{
    //多项式系数
    //    for(int i=0;i<=n;i++)
    //      std::cin>>a[i];
 	double sum=0;
 	for(int i=0;i<=n;i++)
 		sum=sum*x+a[i];
	return sum; 
}
```

##### 引用绑定

```
int &k=dp[i][j][ii][jj];//k引用绑定 相当于dp[i][j][ii][jj]起了别名，可以进行修改
```









# C++ STL(用时间换空间)

## 一、容器

### 向量vector ：动态数组（顺序）

#### 构造及初始化：

##### vector<类型>a(长度，[初始值])

一维：vector<int>a(3,4);

二维：vector<vector<int>>a(5,vector<int>(3,4));

三维：vector<vector<vector<int>>>a(5,vector<vector<int>>(6,vector<int>(4)));

#### 有关函数：

##### 1.尾接：push_back(); /emplace_back();

###### 需要将已有对象添加到 `vector`，可以使用 `push_back()`。但如果要创建一个新对象，并且避免不必要的拷贝，应该使用 `emplace_back()`

##### 2.尾删：pop_back(); 

##### 3.清空：clear a.clear();

##### 4.判空：empty();

##### 5.长度：size(); 

##### 6.改变 resize(长度，初值)；改长赋初值0 改短会删除元素

##### 7.最值  

###### int mx=***max_element**(a.**begin**(),a.**end**());

######   int mi=***min_element**(a.**begin**(),a.**end**());

##### 8.计数 count();   count(s.begin(), s.end(), 2);//统计s中2的次数

##### 9.查找 find()；find(a.begin(),a.end(),1)!=a.end();//查找a中是否存在1

#### 注意：尽量提前确定长度 不要多次push_back()会增加空间复杂度 TLE 

##### size_t溢出 .size()返回值类型为size_t

![image-20240220160901231](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240220160901231.png)



### 栈stack(先进后出)

#### 构造：stack<double>s;

#### 函数：

##### 与vector可以当栈使用

##### 1.进栈  push（);

##### 2.出栈 pop();

##### 3.栈顶 top();

##### 4.判空：empty();

##### 5.长度：size(); 

#### 注意：不可访问栈内元素，只可弹出栈顶



### 队列queue(先进先出)

#### 构造：queue<类型>q;

#### 函数：

##### 1.进队  push();

##### 2.出队 pop();

##### 3.取队首 front();

##### 4.取队尾 back()；

##### 5.判空：empty();

##### 6.长度：size(); 

##### 注意：不可访问队列内元素

### 双端队列deque(两端都可以进出)

#### 函数：

#### 1.尾部进队 push_back()

#### 2.头部进队 push_front()

#### 3.删头 pop_front()

#### 4.删尾 pop_back()

#### 5.取头 front()

#### 6.取尾 back()

#### 7.判空 empty()

#### 8.长度 size()

### 优先队列priority queue(二叉堆) 插入元素就会排序一次

#### 构造：大顶堆priority_queue<int>q; pop 弹出为实时更新的最大值

####            小顶堆 priority_queue<int,vector<int>,greater<int>>q;

#### 函数：

##### 1.进队  push();

##### 2.出队 pop();

##### 3.取队顶 top();

##### 4.弹出 back()；

##### 5.判空：empty();

##### 6.长度：size(); 

#### 注意：元素只读(不可访问和更改队列内元素)，只能访问和修改堆顶



### 集合set(红黑树) 自动排序

#### 三要素：![image-20240222145245637](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240222145245637.png)

#### 构造：set <类型，比较器>st; (比较器默认less<类型>)          set<int>st;

#### 函数：

##### 1.插入 insert();

##### 2.删除 erase();

##### 3.查找 find();![image-20240222152457927](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240222152457927.png)

##### 4.计数 count();st.count(x)

##### 5.判空：empty();

##### 6.清空 clear();

##### 7.长度：size(); 

#### 遍历(迭代器) 注意解引用

![image-20240222150734775](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240222150734775.png)

#### 适用情形：

##### 元素去重

##### 维护顺序

##### 元素是否出现过（范围大）

#### 注意：不存在下标索引(迭代器遍历)，元素只读,不可用迭代器计算下标



### 映射map(红黑树)

![image-20240222151717982](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240222151717982.png)

#### 构造：map<键类型，值类型，比较器>mp； map<int，int>mp;int->int (键从小到大)

#### map<int,int,greater<int>>mp;int->int (键从大到小)

#### 函数：

##### 1.插入 mp[x]=y;

##### 2.删除 erase();

##### 3.查找 find();

###### C++20 中新增了 `contains` 方法，它的作用和 `find` 类似，但使用起来更简洁，返回值是一个布尔值，表示是否找到指定的键。`contains` 直接返回 `true` 或 `false`

##### 4.计数 count();

#### 遍历(迭代器) 

![image-20240222155115845](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240222155115845.png)

##### 基于范围的循环（C++ 11）：

![image-20240222155546452](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240222155546452.png)

#### 适用情形：输入若干字符串，统计每种字符串的出现次数(map<string,int>mp);

#### 注意:中括号访问时默认值，不可用迭代器计算下标



### 字符串string(头文件string)

#### 构造：string(长度，初值)；  赋值 s=“x”；

#### 函数：

##### 1.改查 [];

##### 2.相等 ==；

##### 3.连接 +；string s=s1+s2;

##### 4.尾接 +=；s+=”awa“；

##### 5.取子串 .substr(起始下标，子串长度)；

##### 6.查找子串  .find(字符串，起始下标)；查找字符串a是否包含子串b,不是用strA.find(strB) > 0 而是 strA.find(strB) != string::npos

#### 字符串与数值互转：

##### int/long long /float/double/long double -->string : to_string();

##### string-->int : stoi();

##### string-->float : stof();

##### string-->long long : stoll();

##### string-->double : stod();

##### string-->long double : stold();



### 二元组pair(头文件utility)

#### 构造：pair<第一个值类型，第二个值类型>p；pair<int,int>p={1,3};

#### 函数：

##### 1.取值 第一个 .first 第二个 .second;

##### 2.判同 ==；



### 位运算 bitset(头文件bitset)

#### 构造：bitset<长度>a(十进制数) 默认初始化为0

#### 遍历： 

```
bitset<5>a(2);
//法一
cout<<b<<'\n';//00010
//法二
for(int i=a.size()-1;i>=0;i--)
	cout<<a[i]<<'\n';//00010
```

#### 函数：

##### 1.是否有1： a.any();

##### 2.是否不存在1 ：a.none();

##### 3.计数：a.count();

##### 4.元素个数：a.size();

##### 5.下标为i的元素是否为1：a.test(i);

##### 6.把下标i设置为1 ：a.set(i);

##### 7.所以位取反：a.filp(); 第i位取反： a.filp(i);

##### 8.所以位归零： a.reset();第i位归零 ：a.reset(i);



### tuple:内置字典序比较

```
struct node{
	int a;
	int b;
};
set<node> st;
st.insert({1,2});//这是办不到的，必须重载node的比较函数

set<tuple<int,int>> st;
st.insert({1,2});//√

vector<node> s;
sort(s.begin(),s.end(),cmp);

vector<tuple<int,int>> t;
sort(t.begin(),t.end());//按照字典序，因此你第一个指标需要放在tuple的最前面。
//访问成员
std::tuple<int,int,int,int> t=std::make_tuple(0,3,2,8);
auto i=std::get<0>(t);//返回t的第1个成员
using namespace std;
get<1>(t);//返回t的第2个成员
get<2>(t);//返回t的第3个成员
get<3>(t);//返回t的第4个成员
get<3>(t)=i;//赋值第4个成员的引用

```



## 二、迭代器（与指针相似，针对非线性数据结构）

#### 用法：（vector容器为例）

##### 1.头迭代器 .begin();

##### 2.尾迭代器  .end();指向最后一个元素的后一位

##### 3.反头向迭代器 .rbegin();

##### 4.反向尾迭代器 .rend();

##### 5.迭代器+整型 将迭代器往后移动；

##### 6.迭代器-整型 将迭代器往前移动；

##### 7.迭代器++ 将迭代器往后移动一位；

##### 8.迭代器-- 将迭代器往前移动一位；

##### 9.迭代器-迭代器 两个迭代器的距离；

##### 10.prev(it):返回it前一个迭代器；

##### 11.next(it):返回it后一个迭代器；

#### 注意:不同迭代器功能存在不同（尽量不用迭代器）



## 三、常用算法

#### 算法库(algorithm)

##### 1.交换 swap();

##### 2.反转 reverse();

##### reverse(s.begin(),s.end());

##### 3.去重(去除相同且相邻元素，须排序后再进行去重) unique();![image-20240222223121475](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240222223121475.png)

##### 4.排序 sort(); 

##### 从小到大sort(s.begin(),s.end());

##### 从大到小sort(s.begin(),s.end(),greater<int>()); sort(s.rbegin(),s.rend());

##### 5.二分查找（有序）

#####  lower_bound()/upper_bound(); lower_bound寻找>=x的第一个元素位置，upper_bound寻找>x的第一个元素位置

##### 6.max()/min();

##### 三个数 min/max({a,b,c});

##### 7.比较器

##### 返回值<0:a排在b的前面----升序

##### 返回值>0:b排在a的前面----降序

##### 返回值=0:任意排

![image-20240529195918619](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240529195918619.png)

#### iota函数

##### 它通过指定一个起始值，并根据区间的长度递增生成后续的值。它有助于快速生成递增的序列。

```
int main() {
    std::vector<int> nums(5);
    std::iota(nums.begin(), nums.end(), 1);
    for (const auto& num : nums) {
        std::cout << num << " ";
    }
    std::cout << std::endl;// 1 2 3 4 5
    return 0;
}

for(int i=0;i<n;i++){
	num[i]=i;//等价于当第三个参数为0时
}
```

#### 重载

```
struct node{
	int x,y;
	bool operator<(node &b){
	return x<b.x;// 定义小于运算符
	}
}；
```

#### 字符判断

```
char c = 'c';
char tmp = toupper(c);//将小写字母c转为大写，返回大写c的ASCII码，由于char类型变量接收，内部自动完成转换
char tmp = tolower(c);//将大写字母C转为小写，返回小写c的ASCII码，由于char类型变量接收，内部自动完成转换
isalnum(c);//判断是否在A-Z或a-z或0-9
isdigit(c);//判断是否是数字
islower/isupper
```

##### 数学函数(cmath)

##### 1.abs();

##### 2.exp();

##### 3.log();

##### 4.pow();

##### 5.sqrt();

##### 6.ceil();

##### 7.floor();

##### 8.round();

##### 9.hypot(); 

$$
hypot(a-c,b-d)=sqrt((a-c)*(a-c)+(b-d)*(b-d))
$$

##### 10.next_premutation()  生成全排列

```
    do{
        for(int i=1;i<=n;i++){
            std::cout<<std::setw(5)<<a[i];
        }
        std::cout<<'\n';
    }while(std::next_permutation(a.begin()+1,a.end()));
}
```

#### gcd()/lcm() (c++17) 返回最大公因数/最小公倍数

##### 手搓(辗转相除法)：

![image-20240222224629528](C:\Users\xf\AppData\Roaming\Typora\typora-user-images\image-20240222224629528.png)































